[{"content":"零、系统 linux server 开机网络检测 1 sudo vi /etc/systemd/system/network-online.targets.wants/networking.service1 修改TimeoutStartSec\n1 sudo vi /etc/systemd/system/network-online.target.wants/systemd-networkd-wait-online.service 修改TimeoutStartSec\n修改网卡配置 /etc/netplan/00-installer-config.yaml ，也有可能不是这个名字，一般这个文件夹下面只有一个yaml配置文件，用来配置网卡的信息。在网卡上添加 optional: true 选项 然后重启系统，再看是否还卡同样的问题\n0.2 扩容 Ubuntu Server 22 虚拟机空间扩容\n配置 vmware / virtualbox linux server 中设置 1) 检查未分区空间\n使用 fdisk 命令查看 /dev/sda设备情况\n1 fdisk /dev/sda 输入 F 显示未分区的空间大小\n2) 确定逻辑分区\n2.1) 确定设备\n通过 df -h 命令查看空间，发现挂载到根/目录的设备是 /dev/mapper/ubuntu--vg-ubuntu--lv\n2.2) 确定逻辑分区\n使用 lsblk 查看分区信息，发现 ubuntu--vg-ubuntu--lv是在/dev/sda3下的逻辑分区，所以需要将未分区的空间添加到 /sda/sda3分区下\n3) 扩容\n3.1) 调整物理卷的大小\n当磁盘大小发生变化后，需要使用 pvresize 调整物理卷的大小\n1 pvresize /dev/sda3 Physical volume \u0026ldquo;/dev/sda3\u0026rdquo; changed\n1 physical volume(s) resized or updated / 0 physical volume(s) not resized\n3.2) 扩容分区\n通过 growpart 将未分区空间添加到 /dev/sda 设备的逻辑分区 3 下面\n1 growpart /dev/sda 3 CHANGED: partition=3 start=6397952 old: size=77486080 end=83884032 new: size=161374175 end=167772127\n3.3) 使用所有空闲空间为逻辑分区扩容\n使用 lvresize 命令进行扩容，将所有空闲的空间都分配给 /dev/mapper/ubuntu--vg-ubuntu--lv；需要注意的是 /dev/mapper/ubuntu--vg-ubuntu--lv名称中间是两个 -符号\n1 lvresize -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv Size of logical volume ubuntu-vg/ubuntu-lv changed from 18.47 GiB (4729 extents) to \u0026lt;36.95 GiB (9458 extents).\nLogical volume ubuntu-vg/ubuntu-lv successfully resized.\n3.4). 扩展文件系统本身\n扩容完成后，需要扩展文件系统本身，让系统能够使用新的可用的逻辑分区\n1 resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv resize2fs 1.46.5 (30-Dec-2021)\nFilesystem at /dev/mapper/ubuntu\u0026ndash;vg-ubuntu\u0026ndash;lv is mounted on /; on-line resizing required\nold_desc_blocks = 3, new_desc_blocks = 5\nThe filesystem on /dev/mapper/ubuntu\u0026ndash;vg-ubuntu\u0026ndash;lv is now 9684992 (4k) blocks long.\n3.5) 检查分区大小\n使用 df 命令再次检查分区大小，发现 / 挂载的空间大小已经扩容完成了\n1 df -hT Filesystem Type Size Used Avail Use% Mounted on\ntmpfs tmpfs 796M 1.4M 794M 1% /run\n/dev/mapper/ubuntu\u0026ndash;vg-ubuntu\u0026ndash;lv ext4 40G 19G 21G 47% /\ntmpfs tmpfs 3.9G 0 3.9G 0% /dev/shm\ntmpfs tmpfs 5.0M 0 5.0M 0% /run/lock\n/dev/sda2 ext4 2.0G 127M 1.7G 7% /boot\n/dev/sda1 vfat 1.1G 5.3M 1.1G 1% /boot/efi\ntmpfs tmpfs 796M 4.0K 796M 1% /run/user/0\n1、修改中文 1 2 3 4 export LANG=en_US xdg-user-dirs-gtk-update #接着输入如下命令，然后关闭终端并重启 export LANG=zh_CN 2、镜像 2.1 docker 1 2 3 4 5 6 7 8 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://g25jcx74.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 3、账户 3.1 创建 addsuer 含有引导， useradd 需要参数（三无）\n3.2 密码修改 1 sudo passwd username 可以修改为低强度密码\n一、远程 ssh 1 2 3 4 sudo apt install openssh-server service ssh start service ssh status ip a zerotier 1 2 3 4 5 6 sudo apt install curl #curl curl -s https://install.zerotier.com | sudo bash sudo systemctl start zerotier-one.service sudo zerotier-cli join xxxxxxxxxxxxxxxx #加入 sudo zerotier-cli info #信息 sudo zerotier-cli listnetworks #列表 查询节点：\nzerotier-cli peers\n离开网络：\nzerotier-cli leave xxxxxxxxxxx\n获取地址和服务状态\nzerotier-cli status\n二、编译 C/C++ 1 2 3 sudo apt install build-essential sudo apt install vim vim ~/.vimrc 三、共享 VMware 挂载 1 2 3 sudo mkdir -p /mnt/hgfs sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other sudo vmhgfs-fuse .host:/vmshare /mnt/hgfs -o allow_other 1、内核4.0以前的共享方法：\nmount -t vmhgfs .host:/ /mnt/hgfs\n2、内核4.0之后的共享方法\nvmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other\n自动挂载 1 2 sudo cp /etc/fstab /etc/fstab.bak sudo vim /etc/fstab 在最后一行插入这样一句\n.host:/vmshare /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0\n.host:/ /mnt/share fuse.vmhgfs-fuse allow_other 0 0 #或者尝试\nVirtualBox 1 2 mkdir share sudo mount -t vboxsf vbshare ~/Desktop/fileshare sudo umount -f /mnt/shared\n","date":"2026-01-29T03:34:08+08:00","permalink":"https://windovec.github.io/redeem/p/linux/","title":"Linux"},{"content":"MIUI14包名列表及其用途解释 com.android.camera - 系统相机应用，用于拍照和录像。\ncom.miui.daemon - MIUI后台守护程序，可能用于系统监控和性能优化。\ncom.android.updater - 系统更新管理，负责软件更新。\ncom.miui.powerkeeper - 电池管理，优化电池使用和续航。\ncom.qti.phone - 高通提供的电话相关服务，支持电话功能。\ncom.miui.miservice - MIUI服务，可能涉及设备与MIUI账户的连接。\ncom.miui.miwallpaper.overlay.customize - 自定义壁纸的覆盖服务。\ncom.miui.tsmclient - 支持NFC支付和安全管理。\ncom.android.modulemetadata - 管理Android模块的元数据。\ncom.android.connectivity.resources - 处理设备连接性资源，可能涉及网络和连接管理。\nandroid.miui.overlay - MIUI的系统界面覆盖层。\ncom.android.calllogbackup - 通话记录备份服务。\ncom.qti.diagservices - 高通的诊断服务，可能用于设备故障排除。\ncom.qualcomm.qti.lpa - 高通提供的本地个人助手服务。\nandroid.miui.home.launcher.res - MIUI的启动器资源，管理主屏幕和应用抽屉。\ncom.qualcomm.atfwd - 高通提供的远程AT命令转发服务。\ncom.qualcomm.qti.cne - 高通的连接性引擎，优化网络连接。\ncom.android.overlay.gmscontactprovider - 提供Google移动服务(GMS)联系人相关功能的覆盖服务。\ncom.miui.securitycore - MIUI的安全核心服务，保护系统安全。\ncom.android.providers.contacts - 系统联系人提供程序，管理联系人数据库。\ncom.miui.vpnsdkmanager - VPN SDK管理，支持VPN功能。\ncom.qualcomm.uimremoteserver - 高通的远程SIM管理服务。\ncom.miui.settings.rro.device.systemui.overlay - MIUI设置中的系统UI覆盖层。\ncom.miui.nextpay - MIUI的支付服务，支持下一代支付技术。\ncom.android.dreams.basic - 基本的屏幕保护程序管理。\ncom.android.companiondevicemanager - 伴侣设备管理，管理与其他设备的连接和互动。\ncom.android.cts.priv.ctsshim - CTS(兼容性测试套件)的私人组件，用于兼容性测试。\ncom.android.mms.service - 短信和彩信服务，支持消息传递功能。\ncom.android.providers.downloads - 系统下载管理器，管理文件下载。\ncom.miui.mediaviewer - MIUI的媒体查看器，用于查看照片、视频等内容。\ncom.android.bluetoothmidiservice - 蓝牙MIDI服务，支持音乐设备的MIDI连接。\ncom.miui.carlink - MIUI的车载连接服务。\ncom.android.networkstack.overlay - 网络堆栈的覆盖层，管理网络功能。\ncom.xiaomi.xmsf - 小米推送服务框架，支持推送通知功能。\ncom.google.android.printservice.recommendation - Google打印服务推荐，支持设备打印功能。\ncom.miui.privacycomputing - MIUI隐私计算，保护用户隐私和数据。\ncom.miui.voiceassist - MIUI语音助手，支持语音命令和控制。\ncom.xiaomi.micloud.sdk - 小米云服务SDK，支持云存储和同步。\ncom.android.keychain - 管理和存储加密密钥的系统服务。\ncom.xiaomi.metoknlp - 小米提供的定位服务，可能与NLP（自然语言处理）相关。\ncom.qti.service.colorservice - 高通的颜色管理服务，优化显示效果。\ncom.qualcomm.qti.confdialer - 高通提供的电话配置拨号器服务。\ncom.qualcomm.qti.devicestatisticsservice - 设备统计服务，收集和分析设备使用数据。\ncom.android.shell - 系统Shell命令行工具。\ncom.miui.micloudsync - MIUI云同步服务，支持数据在云端的同步。\ncom.android.wifi.resources.xiaomi - 小米的Wi-Fi资源管理。\ncom.miuix.editor - MIUI编辑器，用于编辑图片或视频。\ncom.android.inputdevices - 输入设备管理，支持各种输入设备的连接。\ncom.qti.qualcomm.datastatusnotification - 高通的数据状态通知服务。\ncom.miui.rom - MIUI的ROM管理服务，可能涉及固件更新或管理。\ncom.xiaomi.gnss.polaris - 小米的GNSS（全球导航卫星系统）服务。\ncom.qti.dpmserviceapp - 高通的设备策略管理服务。\ncom.google.android.onetimeinitializer - Google的一次性初始化服务，用于设置设备的初始配置。\ncom.android.carrierconfig.overlay.miui - MIUI运营商配置覆盖层。\ncom.android.apps.tag - NFC标签管理应用。\ncom.miui.touchassistant - MIUI的触摸助手，提供快捷操作功能。\ncom.android.sharedstoragebackup - 共享存储备份服务。\ncom.qualcomm.qti.uimGbaApp - 高通的UIM GBA（通用认证架构）应用。\ncom.qualcomm.qti.ridemodeaudio - 高通的骑行模式音频服务。\ncom.android.providers.media - 媒体内容提供程序，管理媒体文件的存储和访问。\ncom.android.providers.calendar - 日历内容提供程序，管理日历和事件。\ncom.miui.analytics - MIUI的分析服务，收集用户行为数据以优化体验。\ncom.android.incallui - 来电用户界面，管理通话时的界面显示。\ncom.android.providers.blockednumber - 管理被屏蔽号码的内容提供程序。\ncom.google.android.documentsui - Google的文档用户界面，用于文件管理和操作。\ncom.xiaomi.joyose - 小米的娱乐或游戏相关服务。\ncom.android.networkstack.tethering.inprocess - 网络共享（热点）服务的处理进程。\ncom.android.statementservice - 用于声明文件的服务。\ncom.miui.audiomonitor - 音频监控服务，可能用于录音或音频分析。\ncom.android.proxyhandler - 代理处理服务，管理网络代理设置。\ncom.miui.settings.rro.device.hide.statusbar.overlay - 隐藏状态栏的覆盖服务。\ncom.xiaomi.account - 小米账户管理，支持账户的登录和同步。\ncom.xiaomi.mircs - 小米的IRC（网络聊天）服务。\ncom.android.cellbroadcastreceiver.overlay.common - 通用的移动网络广播接收覆盖服务。\ncom.android.safetycenter.resources - 安全中心资源，支持设备安全功能。\ncom.android.managedprovisioning - 设备管理配置服务。\ncom.android.emergency - 紧急服务，提供紧急情况下的帮助。\ncom.google.android.gms.location.history - Google的位置历史记录服务。\ncom.miui.mishare.connectivity - MIUI的无线共享连接服务，支持文件快速共享。\ncom.miui.aod - MIUI的息屏显示功能，显示锁屏时钟和通知。\ncom.google.android.overlay.gmsconfig - Google移动服务配置的覆盖服务。\ncom.qualcomm.location - 高通的定位服务，支持设备定位功能。\ncom.android.carrierdefaultapp - 默认的运营商应用，管理与运营商相关的设置。\ncom.miui.translationservice - MIUI翻译服务，支持文本翻译功能。\ncom.xiaomi.payment - 小米支付应用，支持小米支付服务。\ncom.android.backupconfirm - 备份确认服务，确保备份操作的安全性。\ncom.xiaomi.mi_connect_service - 小米连接服务，管理小米设备间的连接。\ncom.miui.uireporter - MIUI用户界面报告器，用于收集界面使用数据。\ncom.android.server.telecom.overlay.miui - MIUI定制的电话服务覆盖层。\ncom.android.nfc - NFC服务，支持近场通信功能。\ncom.goodix.fingerprint.setting - Goodix指纹设置服务，管理指纹识别功能。\ncom.android.carrierconfig.overlay.common - 通用的运营商配置覆盖层。\ncom.android.cellbroadcastservice - 移动网络广播服务，支持紧急广播功能。\ncom.android.mtp - 媒体传输协议(MTP)服务，管理设备与电脑之间的文件传输。\ncom.google.android.gsf - Google服务框架，支持Google Play和其他Google服务的基础设施。\ncom.android.systemui.navigation.bar.overlay - 导航栏的覆盖层，管理系统的导航栏样式。\ncom.miui.translation.kingsoft - 金山词霸的MIUI定制版翻译服务。\ncom.android.internal.display.cutout.emulation.double - 双显示缺口仿真服务，用于模拟有两个缺口的设备屏幕。\ncom.android.theme.font.notoserifsource - Noto Serif字体主题包。\ncom.qualcomm.qti.remoteSimlockAuth - 高通的远程SIM锁认证服务。\ncom.mobiletools.systemhelper - 系统辅助工具，可能提供系统优化和管理功能。\ncom.xiaomi.simactivate.service - 小米SIM卡激活服务。\ncom.miui.personalassistant - MIUI个人助理，提供智能助理功能。\ncom.android.server.telecom.overlay.common - 通用的电话服务覆盖层。\ncom.wapi.wapicertmanage - WAPI（无线局域网身份认证与隐私基础结构）认证管理。\ncom.qualcomm.qti.xrcb - 高通提供的XRCB服务，可能与增强现实（AR）相关。\ncom.android.browser - 系统浏览器应用。\ncom.miui.guardprovider - MIUI的安全卫士应用，提供安全保护功能。\ncom.miui.cloudbackup - MIUI云备份服务，支持数据的云端备份。\ncom.android.managedprovisioning.overlay - 管理型设备的配置覆盖层。\ncom.android.systemui - 系统UI，管理系统的用户界面。\ncom.android.wallpapercropper - 壁纸裁剪工具，调整壁纸尺寸以适应屏幕。\ncom.miui.contentcatcher - MIUI内容捕捉服务，可能用于智能识别和操作内容。\ncom.qualcomm.qti.uceShimService - 高通的UCE（统一通信增强）服务。\ncom.android.internal.systemui.navbar.gestural - 手势导航栏的内部系统UI服务。\ncom.qti.dcf - 高通的DCF（动态颜色滤波）服务，优化显示效果。\ncom.miui.systemui.overlay.devices.android - MIUI设备的系统UI覆盖层。\ncom.android.settings.intelligence - 智能设置服务，提供智能建议和自动配置功能。\ncom.qualcomm.timeservice - 高通时间服务，管理设备的时间同步。\ncom.xiaomi.macro - 小米宏服务，可能用于自动化任务管理。\ncom.qualcomm.qti.qcolor - 高通的QColor服务，管理颜色配置。\ncom.lbe.security.miui - LBE安全服务，提供MIUI的安全防护功能。\ncom.android.settings.overlay.miui - MIUI定制的设置应用覆盖层。\ncom.android.wifi.resources.overlay.kalama - 针对Kalama设备的Wi-Fi资源覆盖层。\ncom.miui.phrase - MIUI短语管理服务，可能用于输入法的短语功能。\ncom.qualcomm.wfd.service - 高通无线显示服务，支持Miracast等无线显示功能。\ncom.android.overlay.gmssettings - Google移动服务设置的覆盖层。\nvendor.qti.imsrcs - 高通的IMS RCS服务，支持增强信息服务。\ncom.miui.extraphoto - MIUI的额外照片服务，可能用于照片管理或编辑。\ncom.bsp.catchlog - BSP日志捕获工具，用于调试和错误报告。\ncom.google.android.webview - Google的WebView组件，用于在应用中显示网页内容。\ncom.qualcomm.qti.gpudrivers.kalama.api33 - 高通的Kalama设备GPU驱动API 33版本。\ncom.android.wallpaperbackup - 壁纸备份服务，保存和恢复壁纸设置。\ncom.miui.securityadd - MIUI的安全增强功能，提供额外的安全保护。\ncom.android.overlay.cngmstelecomm - 中国定制版Google移动服务电信覆盖层。\ncom.android.internal.systemui.navbar.threebutton - 三按钮导航栏的内部系统UI服务。\ncom.miui.systemAdSolution - MIUI的系统广告解决方案，可能用于广告展示和管理。\ncom.miui.core - MIUI核心服务，提供系统的基本功能支持。\ncom.miui.settings.rro.device.type.overlay - MIUI设置的设备类型覆盖层。\ncom.android.localtransport - 本地传输服务，可能用于数据传输。\nandroid - Android系统核心包，提供系统的基本功能。\ncom.xiaomi.touchservice - 小米触控服务，管理触摸屏的交互。\ncom.android.permissioncontroller - 权限控制器，管理应用的权限请求和分配。\ncom.qualcomm.qti.dynamicddsservice - 高通的动态数据服务，管理多SIM卡的数据连接。\ncom.miui.dmregservice - MIUI的设备管理注册服务。\ncom.miui.face.overlay.miui - MIUI的面部识别覆盖层。\ncom.android.se - 安全元素服务，管理设备的安全元素（如SIM卡、NFC）。\ncom.android.pacprocessor - PAC（代理自动配置）处理器，管理网络代理配置。\ncom.miui.accessibility - MIUI的无障碍服务，支持残障用户的设备使用。\ncom.android.providers.media.module - 媒体内容提供模块，管理媒体文件的存储和访问。\ncom.miui.freeform - MIUI的自由窗口模式服务，支持多任务操作。\ncom.xiaomi.digitalkey - 小米的数字钥匙服务，可能用于智能家居或汽车解锁。\ncom.miui.contentextension - MIUI内容扩展服务，支持扩展内容功能。\ncom.qualcomm.embms - 高通的eMBMS服务，支持增强型多播广播服务。\ncom.android.stk - SIM卡工具包服务，支持运营商的SIM卡功能。\ncom.android.overlay.systemui - 系统UI的覆盖层，管理界面显示。\ncom.android.camera.overlay - 相机应用的覆盖层，管理相机功能。\ncom.android.internal.display.cutout.emulation.hole - 单摄像头孔屏的仿真服务。\ncom.android.settings - 系统设置应用，管理设备的各项设置。\ncom.android.bips - 基本打印服务，支持设备的打印功能。\ncom.qualcomm.qti.telephonyservice - 高通提供的电话服务，管理电话通信相关的功能。\ncom.android.internal.systemui.navbar.gestural_narrow_back - 狭窄手势导航栏的内部系统UI服务。\ncom.xiaomi.bluetooth - 小米蓝牙服务，管理设备的蓝牙功能。\ncom.android.internal.display.cutout.emulation.tall - 高屏幕切口仿真服务，适应有高切口的设备。\ncom.android.cameraextensions - 相机扩展服务，提供增强的相机功能。\ncom.miui.maintenancemode - MIUI维护模式，设备维护或故障排除时使用。\ncom.android.carrierconfig - 运营商配置服务，管理与运营商相关的配置文件。\ncom.android.internal.systemui.navbar.gestural_wide_back - 宽手势导航栏的内部系统UI服务。\ncom.android.overlay.gmstelephony - Google移动服务电话功能的覆盖层。\ncom.xiaomi.finddevice - 小米查找设备服务，帮助用户定位遗失的设备。\ncom.google.android.ext.shared - Google共享扩展服务，支持共享功能。\ncom.miui.packageinstaller - MIUI包安装程序，管理应用的安装和更新。\ncom.android.networkstack.inprocess - 网络堆栈进程内服务，管理网络连接。\ncom.xiaomi.xmsfkeeper - 小米消息服务守护程序，保持消息传递服务的正常运行。\ncom.miui.notification - MIUI通知管理服务，处理系统通知。\norg.codeaurora.ims - Code Aurora提供的IMS服务，支持IP多媒体子系统功能。\ncom.ifaa.seccam - IFAA（互联网金融身份认证联盟）安全摄像头服务，用于安全认证。\ncom.android.remoteprovisioner - 远程配置服务，支持设备的远程管理。\ncom.qualcomm.qcrilmsgtunnel - 高通的QCRIL消息通道服务，管理消息传输。\ncom.android.incallui.overlay - 通话界面的覆盖层，管理通话时的用户界面。\nandroid.overlay.common - 通用系统覆盖层，适用于多种设备的通用设置。\ncom.xiaomi.location.fused - 小米融合定位服务，整合多个定位方式以提高定位精度。\ncom.xiaomi.aireco - 小米的AI推荐服务，提供个性化的内容推荐。\ncom.android.adservices.api - 广告服务API，支持广告相关的功能。\ncom.rongcard.eid - 容联eID服务，可能用于身份验证。\ncom.modemdebug - 调制解调器调试工具，用于调试移动通信模块。\nmiui.systemui.plugin - MIUI系统UI插件，提供扩展的UI功能。\ncom.miui.bugreport - MIUI的错误报告工具，用于提交错误报告。\ncom.android.smspush - 短信推送服务，支持短信的推送和接收。\ncom.google.android.marvin.talkback - Google的TalkBack服务，为视障用户提供语音反馈。\ncom.miui.yellowpage - MIUI黄页服务，提供电话本和企业信息。\nvendor.qti.hardware.cacert.server - 高通硬件CA证书服务器，管理设备的证书认证。\ncom.xiaomi.aiasst.service - 小米人工智能助手服务，提供AI助手功能。\ncom.xiaomi.cameratools - 小米相机工具，提供相机的高级功能和设置。\ncom.miui.catcherpatch - MIUI捕获补丁服务，可能用于捕捉错误或数据。\ncom.qualcomm.qti.performancemode - 高通性能模式服务，优化设备性能。\ncom.miui.miwallpaper - MIUI壁纸管理服务，提供动态壁纸和主题功能。\ncom.android.ons - ONS（运营商网络服务）服务，管理设备的网络连接。\ncom.miui.cit - MIUI CIT（硬件检测工具），用于设备的硬件测试。\ncom.miui.vsimcore - MIUI虚拟SIM核心服务，管理虚拟SIM卡功能。\ncom.android.certinstaller - 证书安装器，管理设备的证书安装和认证。\ncom.miui.hybrid - MIUI混合应用框架，支持混合应用的开发和运行。\ncom.miui.system - MIUI系统核心，提供系统的基本功能和服务。\ncom.qualcomm.uimremoteclient - 高通的远程UIM（用户身份模块）客户端，管理SIM卡功能。\ncom.android.wifi.resources - Wi-Fi资源服务，管理设备的Wi-Fi连接。\ncom.android.wifi.dialog - Wi-Fi对话框服务，管理Wi-Fi连接时的用户界面。\ncom.android.captiveportallogin - 网络登录门户服务，支持公共Wi-Fi的认证登录。\ncom.xiaomi.market - 小米应用市场，提供应用下载和更新服务。\ncom.qti.snapdragon.qdcm_ff - 高通骁龙显示校准管理服务，优化设备显示效果。\ncom.qualcomm.qti.server.qtiwifi - 高通Wi-Fi服务器，管理设备的Wi-Fi功能。\ncom.miui.systemui.carriers.overlay - MIUI运营商UI覆盖层，定制运营商相关的UI。\ncom.xiaomi.otrpbroker - 小米OTRP（一次性密码）代理服务，管理一次性密码功能。\ncom.miui.backup - MIUI备份服务，支持数据的备份和恢复。\ncom.miui.securitycenter - MIUI安全中心，提供系统的安全保护功能。\ncom.qualcomm.qti.powersavemode - 高通省电模式服务，管理设备的省电功能。\ncom.android.fileexplorer - 文件浏览器，管理设备的文件和目录。\ncom.android.simappdialog - SIM应用对话框服务，管理SIM卡相关的设置对话框。\ncom.android.providers.telephony - 电话服务提供者，管理设备的电话和短信功能。\ncom.android.wallpaper.livepicker - 动态壁纸选择器，管理动态壁纸的设置。\ncom.android.systemui.overlay.common - 通用系统UI覆盖层，适用于多种设备的UI设置。\ncom.fido.asm - FIDO（快速身份在线）认证模块，支持生物认证功能。\ncom.android.sdksandbox - SDK沙盒，提供应用开发测试环境。\ncom.miui.audioeffect - MIUI音效管理服务，提供音效增强和配置功能。\ncom.xiaomi.xaee - 小米XAEE服务，可能与安全或隐私保护相关。\ncom.xiaomi.barrage - 小米弹幕服务，可能用于视频或直播中的弹幕功能。\ncom.qualcomm.qti.poweroffalarm - 高通关机闹钟服务，支持设备关机状态下的闹钟功能。\ncom.xiaomi.aon - 小米Always-on-Display服务，管理屏幕常亮显示功能。\ncom.android.internal.display.cutout.emulation.waterfall - 瀑布屏仿真服务，适应有瀑布屏的设备。\ncom.quicinc.voice.activation - 高通语音激活服务，支持语音唤醒功能。\ncom.miui.qr - MIUI二维码服务，管理二维码的生成和扫描功能。\ncom.android.providers.settings - 设置提供者，管理系统设置的存储和访问。\ncom.android.overlay.gmssettingprovider - Google移动服务设置提供者的覆盖层。\nvendor.qti.iwlan - 高通的IWLAN（集成无线局域网）服务，管理无线网络连接。\ncom.android.phone - 电话应用，管理设备的电话功能\ncom.google.android.overlay.modules.ext.services - Google扩展服务模块的覆盖层，提供与Google服务相关的扩展功能。\ncom.android.internal.systemui.navbar.gestural_extra_wide_back - 超宽手势导航栏的内部系统UI服务，提供更宽的返回手势。\ncom.android.stk.overlay.miui - MIUI中的STK（SIM Toolkit）服务覆盖层，管理SIM卡工具包功能。\ncom.android.systemui.gesture.line.overlay - 系统手势线条覆盖层，用于提供手势导航功能。\nandroid.aosp.overlay - AOSP（Android开源项目）的覆盖层，为设备提供基础功能。\ncom.android.traceur - Traceur是Android中的调试工具，用于记录系统的跟踪信息。\ncom.miui.hybrid.accessory - MIUI混合应用附件服务，支持混合应用的开发和运行。\ncom.qualcomm.qti.autoregistration - 高通自动注册服务，可能用于设备的网络或服务自动注册。\ncom.android.contacts - Android通讯录应用，管理联系人信息。\ncom.miui.vipservice - MIUI VIP服务，为用户提供高级服务或支持。\ncom.xiaomi.mirror - 小米镜像服务，支持设备屏幕镜像到其他设备。\ncom.android.overlay.gmstelecomm - Google移动服务通信功能的覆盖层，管理与通信相关的Google服务。\ncom.android.location.fused - 融合定位服务，整合多种定位方式以提高定位精度。\ncom.android.vpndialogs - VPN对话框服务，管理VPN连接的用户界面。\ncom.android.uwb.resources - 超宽带（UWB）资源服务，管理超宽带通信功能。\ncom.miui.screenshot - MIUI截屏服务，支持设备的截屏功能。\ncom.android.cellbroadcastreceiver - 紧急广播接收器，接收政府或运营商的紧急广播信息。\ncom.qualcomm.qti.biometrics.fingerprint.service - 高通的生物识别指纹服务，管理指纹识别功能。\ncom.xiaomi.migameservice - 小米游戏服务，管理小米设备上的游戏相关功能。\ncom.miui.voicetrigger - MIUI语音触发服务，支持通过语音唤醒设备。\ncom.android.settings.overlay.common - 通用设置的覆盖层，管理设备的设置界面和功能。\ncom.android.wifi.resources.overlay.common - 通用Wi-Fi资源覆盖层，管理设备的Wi-Fi连接和设置。\ncom.qualcomm.qtil.btdsda - 高通蓝牙服务（BTDSDA），管理设备的蓝牙连接。\ncom.google.android.cellbroadcastreceiver.overlay.miui - MIUI中Google紧急广播接收器的覆盖层。\ncom.android.phone.overlay.common - 通用电话应用覆盖层，管理设备的电话功能。\ncom.android.ondevicepersonalization.services - 设备上的个性化服务，提供个性化推荐和设置。\ncom.android.htmlviewer - HTML查看器，用于在设备上查看HTML文件。\ncom.qti.qualcomm.deviceinfo - 高通设备信息服务，提供设备的硬件和软件信息。\ncom.android.vending - Google Play商店应用，提供应用下载和更新服务。\ncom.miui.home - MIUI桌面应用，管理设备的主屏幕和应用布局。\ncom.google.android.ext.services - Google扩展服务，为Android提供额外的功能和支持。\ncom.google.android.configupdater - Google配置更新器，更新设备上的配置文件。\nandroid.qvaoverlay.common - 通用QVA覆盖层，可能与视频增强相关。\ncom.miui.wmsvc - MIUI无线管理服务，管理无线连接和设备间通信。\nandroid.overlay.target - 目标设备的系统覆盖层，提供特定设备的功能。\ncom.miui.system.overlay - MIUI系统的覆盖层，定制系统的用户界面和功能。\ncom.xiaomi.gamecenter.sdk.service - 小米游戏中心SDK服务，管理游戏相关的SDK功能。\ncom.qti.qcc - 高通的QCC服务，可能用于设备的快速充电功能。\norg.ifaa.aidl.manager - IFAA（互联网金融身份认证联盟）AIDL管理服务，支持身份认证功能。\ncom.android.mms - 短信应用，管理设备的短信和多媒体信息功能。\ncom.miui.miinput - MIUI输入法，提供文本输入功能。\ncom.android.providers.settings.overlay - 设置提供者的覆盖层，管理系统设置的存储和访问。\ncom.android.providers.userdictionary - 用户词典提供者，管理用户自定义的词汇。\ncom.android.cts.ctsshim - Android兼容性测试套件（CTS）的Shim应用，支持设备的兼容性测试。\ncom.xiaomi.aiasst.vision - 小米AI助手视觉服务，支持AI助手的视觉识别功能。\ncom.android.bluetooth - Android蓝牙服务，管理设备的蓝牙功能。\ncom.qualcomm.qti.workloadclassifier - 高通工作负载分类器，优化设备的性能和资源分配。\ncom.android.internal.display.cutout.emulation.corner - 角切口仿真服务，适应有角切口的设备。\ncom.google.android.gms - Google Play服务，提供Google相关的核心服务。\ncom.android.storagemanager - 存储管理器，管理设备的存储空间。\ncom.android.quicksearchbox - 快速搜索框，提供设备上的快速搜索功能。\ncom.xiaomi.mtb - 小米MTB服务，可能与小米工具包相关。\ncom.miui.cloudservice - MIUI云服务，支持数据的云同步和备份。\ncom.android.systemui.overlay.miui - MIUI系统UI的覆盖层，定制系统的用户界面。\ncom.miui.miwallpaper.wallpaperoverlay.config.overlay - MIUI壁纸覆盖层，管理壁纸的设置和配置。\ncom.milink.service - 小米Milink服务，支持设备间的连接和数据传输。\ncom.android.thememanager - 主题管理器，管理设备的主题和外观设置。\ncom.miui.voiceassistoverlay - MIUI语音助手的覆盖层，支持语音助手功能。\ncom.android.phone.overlay.miui - MIUI电话应用的覆盖层，定制电话相关的UI和功能。\ncom.android.printspooler - 打印后台服务，管理设备的打印功能。\ncom.miui.systemui.devices.overlay - MIUI设备UI覆盖层，为不同设备定制UI。\ncom.miui.otaprovision - MIUI OTA（无线更新）配置服务，管理系统的OTA更新。\ncom.xiaomi.misettings - 小米设置服务，管理设备的系统设置。\ncom.android.wifi.resources.overlay.target - Wi-Fi资源覆盖层，定制设备的Wi-Fi设置。\ncom.miui.misound - MIUI音效管理服务，提供音效增强和配置功能。\ncom.android.se.overlay.target - 安全元素（SE）覆盖层，管理设备的安全功能。\ncom.qualcomm.qti.uim - 高通UIM（用户身份模块）服务，管理SIM卡功能。\ncom.android.provision - 配置服务，支持设备的初始设置和配置。\ncom.qualcomm.qti.qms.service.trustzoneaccess - 高通信任区访问服务，管理设备的信任区功能。\ncom.miui.wallpaper.overlay.customize - MIUI壁纸自定义覆盖层，支持壁纸的个性化设置。\ncom.android.dynsystem - 动态系统服务，支持动态系统更新和切换。\norg.mipay.android.manager - 小米支付管理器，管理小米支付相关功能。\ncom.tencent.soter.soterserver - 腾讯Soter服务，支持安全认证和支付功能。\ncom.sohu.inputmethod.sogou.xiaomi - 搜狗输入法小米版，提供文本输入功能。\ncom.android.hotspot2.osulogin - Hotspot 2.0登录服务，管理设备的Hotspot 2.0连接。\ncom.unionpay.tsmservice.mi - 小米银联TSM（可信服务管理）服务，支持银联支付。\ncom.google.android.cellbroadcastservice.overlay.miui - MIUI中Google紧急广播服务的覆盖层。\ncom.android.externalstorage - 外部存储管理服务，管理设备的SD卡等外部存储。\ncom.miui.translation.xmcloud - 小米云翻译服务，支持翻译功能。\ncom.android.server.telecom - 电信服务，管理设备的通信功能。\ncom.miui.securityinputmethod - MIUI安全输入法，提供安全的文本输入功能。\n代理白名单 包名 应用名 分类 归属 com.github.kr328.clash Clash for Android 代理 clash moe.nb4a NekoBox for Android 代理 singbox com.follow.clash Flclash 代理 mihomo com.github.metacubex.clash.meta Clash Meta for Android 代理 mihomo com.v2ray.ang v2rayNG 代理 Xray ceui.lisa.pixiv Shaft 第三方 pixiv com.github.libretube LibreTube 第三方 YouTube com.perol.pixez PixEz 第三方 pixiv com.picacomic.fregata PicaComic 第三方 哔咔漫画 com.samruston.twitter Twitter Lite 第三方 X free.tube.premium.advanced.tuber Tuber 第三方 YouTube nekox.messenger NekoX 第三方 Telegram niuhuan.pikapika PikaPika 第三方 哔咔漫画 opensource.jmtt2mic jmtt2 第三方 禁漫天堂 org.schabi.newpipe NewPipe 第三方 YouTube org.telegram.plus Plus Messenger 第三方 Telegram tw.nekomimi.nekogram Nekogram 第三方 Telegram bnzyx.n.drqb 伪装 Magisk com.android.shell 伪装 LSPosed be.mygod.vpnhotspot VPN Hotspot ch.protonmail.android ProtonMail cm.aptoide.pt Aptoide cn.wps.moffice_eng WPS Office com.android.email Email com.android.vending Google Play Store com.apkpure.aegon APKPure com.app.pixivic Pixiv com.aurora.store Aurora Store com.aurora.store.nightly Aurora Store Nightly com.azure.authenticator Microsoft Authenticator com.catpuppyapp.puppygit.play.pro PuppyGit Pro com.discord Discord com.dv.adm ADM com.dv.adm.pay ADM Pro com.facebook.katana Facebook com.google.android.apps.authenticator2 Google Authenticator com.google.android.gms Google Play Services com.google.android.gsf Google Services Framework com.google.android.syncadapters.contacts Google Contacts Sync Adapter com.google.android.youtube YouTube com.instagram.android Instagram com.kiwibrowser.browser Kiwi Browser com.microsoft.bing Bing com.microsoft.emmx Edge com.microsoft.emmx.canary Edge Canary com.mxtech.videoplayer.pro MX Player Pro com.sonelli.juicessh JuiceSSH com.ss.android.ugc.trill TikTok com.tencent.androidqqmail QQ Mail com.termux Termux com.topjohnwu.magisk Magisk com.twitter.android X com.uptodown Uptodown com.v2ray.ang V2RayNG com.valvesoftware.android.steam.community Steam com.vanced.manager Vanced Manager com.vmos.pro VMOS Pro com.xmader.aria_ng_gui_android AriaNg GUI com.zhiliaoapp.musically TikTok io.github.a13e300.ksuwebui KernelSU WebUI mark.via Via Browser net.thunderbird.android Thunderbird net.xzos.upgradeall UpgradeAll org.fdroid.fdroid F-Droid org.torproject.torbrowser Tor Browser org.zwanoo.android.speedtest Speedtest ","date":"2026-01-29T03:33:40+08:00","permalink":"https://windovec.github.io/redeem/p/android/","title":"Android"},{"content":"IDE Android Studio 本体 环境变量 NDK 介绍\nAndroid NDK 是一个工具集，可让您使用 C 和 C++ 等语言以原生代码实现应用的各个部分。对于特定类型的应用，这可以帮助您重复使用以这些语言编写的代码库。 文档\nNDK 使用入门 | Android NDK | Android Developers 下载\nNDK 下载 | Android NDK | Android Developers 仅限命令行工具 介绍\nAndroid Studio 中包含命令行工具。如果您不需要 Android Studio，可以从上面下载基本的 Android 命令行工具。您可以使用随附的 sdkmanager 下载其他 SDK 软件包。\nAndroid SDK 命令行工具软件包包含可用于构建和调试 Android 应用的各种工具。此软件包与 Android Studio 同步发布，并将安装在 android_sdk/cmdline-tools/version/bin/ 目录中。\n文档\n命令行工具 | Android Studio | Android Developers\n下载链接\n下载 Android Studio 和应用工具 - Android 开发者 | Android Developers\n组件 sdkmanager 介绍\nsdkmanager 是一个命令行工具，您可以用它来查看、安装、更新和卸载 Android SDK 的软件包。如果使用 Android Studio，则无需使用此工具，而可以从 IDE 管理 SDK 软件包。 文档\nsdkmanager | Android Studio | Android Developers 旧版 SDK-Tools： sdk-tools-windows-3859397.zip sdk-tools-linux-3859397.zip sdk-tools-darwin-3859397.zip 注意： 这些属于旧版的独立命令行工具，已经被上面的 commandlinetools 取代了。\nSDK 平台工具 介绍\nAndroid SDK Platform-Tools 是 Android SDK 的一个组件。它包含与 Android 平台进行交互的工具，主要是 adb 和 fastboot。\n下载链接\nSDK 平台工具版本说明 | Android Studio | Android Developers\nSDK Build Tools 介绍\nAndroid SDK Build-Tools 是构建 Android 应用所需的一个 Android SDK 组件，安装在 \u0026lt;sdk\u0026gt;/build-tools/ 目录中。 SDK 管理器 installer_r24.4.1-windows.exe: Windows 版 SDK 管理器安装程序。\nandroid-sdk_r24.4.1-windows.zip: 免安装版 SDK 基础包。\nandroid-sdk_r24.4.1-linux.tgz: Linux 环境下的旧版 SDK 管理器。\nandroid-sdk_r24.4.1-macosx.zip: Mac (Intel) 环境下的旧版 SDK 管理器。\n(Legacy Installer / SDK R24)，这些是“古董”级别的工具，大约是在 2015 年左右使用的。\n数据库 Microsoft SQL Server 本体 Detailed results:\nFeature: Data Quality Services\nFeature: 全文和语义提取搜索\nFeature: 机器学习服务和语言扩展\nFeature: 数据库引擎服务\nFeature: SQL Server 复制\nFeature: SQL Browser\nFeature: SQL 编写器\nFeature: 安装程序支持文件\n实例 MSSQLSERVER\n管理员账号密码 sa\nmssql9264\n日志 C:\\Program Files\\Microsoft SQL Server\\160\\Setup Bootstrap\\Log\\20250916_225210\\ConfigurationFile.ini\nSQL Server 2022 配置管理器 重启 1 2 net start mssqlserver net stop mssqlserver SSMS 安装 SQL Server Management Studio | Microsoft Learn\n核心\nMySQL 本体 MySQL Community (GPL) Downloads »\nMySQL Installer for Windows Windows (x86, 32-bit), MSI Installer\n重启 1 2 net start mysql net stop mysql 功能选择 实例 MySQL80\n管理员账号密码 root\nmysql9264\n环境变量 MYSQL_HOME\nE:\\Program Files\\MySQL\\MySQL Server 8.0\nPath\n%MYSQL_HOME%\\bin\nWorkbench Shell 异地组网 特性 Tailscale ZeroTier EasyTier VNT 底层协议 WireGuard (现代/安全) 自研 ZT 协议 Rust 编写 (高性能) C/Rust 编写 (轻量) 账号体系 必须登录 (Google/GitHub) 必须注册官方账号 无需账号 (共享密钥) 无需账号 (组名+密码) 控制中心 云端托管 (官方控制台) 云端托管 (官方控制台) 完全去中心化 需自建或使用公共服务端 NAT 穿透 极强 (DERP 中继) 强 (轨道服务器) 极强 (针对国内优化) 强 (混淆能力好) 配置难度 极低 (开箱即用) 较低 (需后台授权) 极低 (单文件运行) 中等 (命令行/配置文件) EasyTier GitHub 地址 ：EasyTier/EasyTier 官方文档：EasyTier - 简单、安全、去中心化的异地组网方案 特点：无需注册，去中心化，适合跨运营商的高速 P2P 连接。 VNT GitHub 地址： vnt-dev/vnt 项目主页/文档： 首页 | VNT 特点：C/Rust 编写，资源占用极低，抗封锁能力强，适合路由器部署。 Tailscale GitHub 地址：tailscale/tailscale 官方文档：Docs · Tailscale Docs 下载：pkgs.tailscale.com/stable/ 特点：基于 WireGuard，安全性极高，支持 MagicDNS，全平台 App 覆盖，国内建议配合自建 DERP 中继。 ZeroTier GitHub 地址： zerotier/ZeroTierOne 官方文档：Getting Started with ZeroTier | ZeroTier Documentation 特点：模拟二层以太网，像物理网线一样工作，特别适合需要局域网发现（如游戏、老旧软件）的场景。 WireGuard GitHub 地址： WireGuard 官方文档：Quick Start - WireGuard 特点：性能的巅峰。代码量极小，安全性极高，几乎所有现代操作系统内核都已内置。需要手动管理每个设备的密钥、IP、路由。最致命的是：它没有自动打洞能力。如果两端都没有公网 IP，原生 WireGuard 几乎无法直接建立连接。 串流 - 服务端 sunshine Sunshine 文档：Sunshine: Sunshine ViGEmBus（手柄） foundation-sunshine（sunshine 基地版） 文档：Sunshine基地版使用手册初版 Apollo（sunshine fork） 串流 - 客户端 moonlight 配置 基本设置 - 视频分辨率 - 本地 基本设置 - 视频帧数 基本设置 - 视频帧速调节 主机设置 - 在电脑上播放声音 输入设置 - 将触控屏作为触控板使用 - 关闭 高级设置 - HDR moonlight-android moonlight-android（黑月亮） moonlight-android（moonlight 阿西西版） moonlight-vplus（moonlight 威力加强版） moonlight-android（moonlight 皇冠版） ","date":"2026-01-29T03:26:46+08:00","permalink":"https://windovec.github.io/redeem/p/swr/","title":"SWR"},{"content":"Clash Meta (mihomo) 链式代理 官方文档： dialer-proxy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 proxies: - name: \u0026#34;ss1\u0026#34; dialer-proxy: dialer ... - name: \u0026#34;ss2\u0026#34; ... proxy-groups: - name: dialer type: select proxies: - ss2 rules: - MATCH,ss1 指定当前 proxies 通过 dialer-proxy 建立网络连接，值可以为策略组/出站代理的 name\n上述示例中，ss1 通过 ss2 建立连接\n当通过 ss1 代理时，就组成了一条 內核 ---ss1--\u0026gt; ss2包裝器 ===ss2==\u0026gt; ss2服務端 ---ss1--\u0026gt; ss1服務端 --\u0026gt; 目标 的代理链\n最终表现：\n浏览器访问IP查询网站时只会显示ss1的IP（即目标网站不知道ss2的存在） 内核对外看起来只是在访问ss2（即你的宽带运营商不知道ss1的存在） 只有ss2的服务端知道在访问ss1（ss2的服务端也只知道在访问ss1，并不知道在访问什么目标网站） 1 常见实例\n1.1 通过订阅节点中转自己的VPS落地\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 proxies: - name: \u0026#34;ss1\u0026#34; dialer-proxy: dialer ... proxy-providers: provider1: type: http url: \u0026#34;http://test.com\u0026#34; proxy-groups: - name: dialer type: select use: - provider1 rules: - MATCH,ss1 这里将订阅地址填入provider1中，将你自己VPS中搭建的节点填入ss1中即可，此时通过浏览器访问时显示的是ss1的IP\nNote 没有特殊需求的情况下，在自己被中转的VPS落地中搭建的节点请勿选择任何udp类协议如hy2/tuic/wg，以及带有tls伪装类协议如reality/shadowtls，您的订阅节点可能不能正常通过这些协议，这里建议选择最简单的ss aead或者vmess协议\n1.2 通过特定socks连接订阅节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 proxies: - { name: \u0026#34;socks1\u0026#34;, type: \u0026#34;socks\u0026#34; } proxy-providers: provider1: type: http url: \u0026#34;http://test.com\u0026#34; override: dialer-proxy: socks1 proxy-groups: - name: select1 type: select use: - provider1 rules: - MATCH,select1 该实例适用于需要通过一个特定socks才能访问外网的情况（如内外网隔离环境），将环境提供的socks配置填入socks1，将订阅地址填入provider1中，此时通过浏览器访问时显示的是订阅中节点的IP\nNote 这里只是示范了dialer-proxy的相关配置，您可能还需要更多的配置才能保证订阅下载，dns解析等流程同样通过该socks\n2 relay迁移\nrelay类型的proxy-group将被废弃，而proxy-group并不直接支持dialer-proxy，因此针对部分使用场景，给出参考方案\n2.1 relay中包含多个select\n有如下配置\n1 2 3 4 5 6 7 8 9 10 11 proxies: - { name: \u0026#34;proxy1\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy2\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy3\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy4\u0026#34;, type: \u0026#34;socks\u0026#34; } proxy-groups: - { name: \u0026#34;relay-proxy\u0026#34;, type: relay, proxies: [\u0026#34;select1\u0026#34;, \u0026#34;select2\u0026#34;] } - { name: \u0026#34;select1\u0026#34;, type: select, proxies: [\u0026#34;proxy1\u0026#34;, \u0026#34;proxy2\u0026#34;] } - { name: \u0026#34;select2\u0026#34;, type: select, proxies: [\u0026#34;proxy3\u0026#34;, \u0026#34;proxy4\u0026#34;] } rules: - MATCH,relay-proxy 迁移到dialer-proxy方案时，需要将proxy3和proxy4定义到proxy-provider中，并通过override设置该provider中所有proxy的dialer-proxy，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 proxies: - { name: \u0026#34;proxy1\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy2\u0026#34;, type: \u0026#34;socks\u0026#34; } proxy-groups: - { name: \u0026#34;select1\u0026#34;, type: select, proxies: [\u0026#34;proxy1\u0026#34;, \u0026#34;proxy2\u0026#34;] } - { name: \u0026#34;select2\u0026#34;, type: select, use: [\u0026#34;provider1\u0026#34;] } proxy-providers: provider1: type: inline override: dialer-proxy: select1 payload: - { name: \u0026#34;proxy3\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy4\u0026#34;, type: \u0026#34;socks\u0026#34; } rules: - MATCH,select2 人话 可以在 proxies 项中添加 dialer-proxy 属性，值为出站代理/策略组，代表将值作为前置代理\n可以在 proxy-providers 的 inline 项中添加 override:dialer-proxy 属性，将后置代理添加到 payload 属性中\n配置节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 proxies: - name: \u0026#34;ss1\u0026#34; dialer-proxy: dialer ... - name: \u0026#34;ss2\u0026#34; ... proxy-groups: - name: dialer type: select proxies: - ss2 rules: - MATCH,ss1 1 內核 --\u0026gt; ss1 --\u0026gt; ss2包裝器 --\u0026gt; ss2 --\u0026gt; ss2服務端 --\u0026gt; ss1 --\u0026gt; ss1服務端 --\u0026gt; 目标 指定当前 proxies 通过 dialer-proxy 建立网络连接，值可以为策略组/出站代理的 name\n最终表现：\n浏览器访问IP查询网站时只会显示ss1的IP（即目标网站不知道ss2的存在） 内核对外看起来只是在访问ss2（即你的宽带运营商不知道ss1的存在） 只有ss2的服务端知道在访问ss1（ss2的服务端也只知道在访问ss1，并不知道在访问什么目标网站） 配置策略组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 proxies: - { name: \u0026#34;proxy1\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy2\u0026#34;, type: \u0026#34;socks\u0026#34; } proxy-groups: - { name: \u0026#34;select1\u0026#34;, type: select, proxies: [\u0026#34;proxy1\u0026#34;, \u0026#34;proxy2\u0026#34;] } - { name: \u0026#34;select2\u0026#34;, type: select, use: [\u0026#34;provider1\u0026#34;] } proxy-providers: provider1: type: inline override: dialer-proxy: select1 payload: - { name: \u0026#34;proxy3\u0026#34;, type: \u0026#34;socks\u0026#34; } - { name: \u0026#34;proxy4\u0026#34;, type: \u0026#34;socks\u0026#34; } rules: - MATCH,select2 覆写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 proxies+: - name: 302proxy_fixed dialer-proxy: dialer type: socks5 server: XXX port: 3333 username: XXX password: XXXXX proxy-groups+: - name: dialer type: select proxies: - Hysteria2 - Vless-Reality - Torjan - name: 302proxy_fixip type: select proxies: - 302proxy_fixed +rules: - DOMAIN-KEYWORD,cursor,302proxy_fixip 弃置方法：proxy-group 1 2 3 4 5 6 7 8 9 Proxy Groups: # Traffic: Clash \u0026lt;-\u0026gt; http \u0026lt;-\u0026gt; vmess \u0026lt;-\u0026gt; ss1 \u0026lt;-\u0026gt; ss2 \u0026lt;-\u0026gt; Internet - name: \u0026#34;relay\u0026#34; type: relay proxies: - http - vmess - ss1 - ss2 The traffic flow is Clash \u0026lt;-\u0026gt; http \u0026lt;-\u0026gt; vmess \u0026lt;-\u0026gt; ss1 \u0026lt;-\u0026gt; ss2 \u0026lt;-\u0026gt; Internet.\n脚本 添加出站代理 dialer策略组复制策略组版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 function main(config) { // ================= 配置区域 ================= const customNodes = [ { name: \u0026#34;1024proxy-US\u0026#34;, type: \u0026#34;socks5\u0026#34;, server: \u0026#34;us.1024proxy.io\u0026#34;, port: 3000, udp: true, username: \u0026#34;your-username\u0026#34;, // 请替换真实账号 password: \u0026#34;your-password\u0026#34; // 请替换真实密码 // dialer-proxy 将由脚本自动注入 }, // 可以添加更多... ]; // =========================================== // 1. 基础安全检查 if (!Array.isArray(config.proxies)) config.proxies = []; if (!Array.isArray(config[\u0026#34;proxy-groups\u0026#34;])) config[\u0026#34;proxy-groups\u0026#34;] = []; // 2. 获取默认策略组（通常是列表里的第一个） // 如果没有策略组，直接返回，避免报错 if (config[\u0026#34;proxy-groups\u0026#34;].length === 0) return config; const firstGroup = config[\u0026#34;proxy-groups\u0026#34;][0]; // 3. 创建 Dialer 策略组：直接克隆第一个分组 // 我们使用 ...展开运算符复制属性 (type, url, interval, proxies, use 等) // 然后覆盖 name 为 \u0026#39;dialer\u0026#39; const dialerGroup = { ...firstGroup, name: \u0026#34;dialer\u0026#34; }; // 4. 将 Dialer 添加到策略组列表末尾 // 先检查是否存在同名 dialer（防止重复添加），存在则覆盖，不存在则追加 const existingDialerIndex = config[\u0026#34;proxy-groups\u0026#34;].findIndex(g =\u0026gt; g.name === \u0026#34;dialer\u0026#34;); if (existingDialerIndex !== -1) { config[\u0026#34;proxy-groups\u0026#34;][existingDialerIndex] = dialerGroup; } else { config[\u0026#34;proxy-groups\u0026#34;].push(dialerGroup); } // 5. 处理自定义节点并注入 const customNodeNames = []; for (const node of customNodes) { // 5.1 注入 dialer-proxy 属性 // 这使得该节点会走 dialer 策略组的流量 const nodePayload = { ...node, \u0026#34;dialer-proxy\u0026#34;: \u0026#34;dialer\u0026#34; }; // 5.2 添加到全局 proxies 列表 // 检查重名，避免重复添加 const idx = config.proxies.findIndex(p =\u0026gt; p.name === node.name); if (idx !== -1) { config.proxies[idx] = nodePayload; } else { config.proxies.push(nodePayload); } // 记录名字以便后续添加到分组 customNodeNames.push(node.name); } // 6. 将自定义节点添加到第一个分组（默认分组）的末尾 // 注意：我们在步骤 3 已经克隆了 firstGroup 给 dialer // 所以现在修改 firstGroup 不会影响 dialer（避免死循环） if (!Array.isArray(firstGroup.proxies)) firstGroup.proxies = []; customNodeNames.forEach(name =\u0026gt; { // 移除旧的同名引用（保持整洁） const idx = firstGroup.proxies.indexOf(name); if (idx !== -1) firstGroup.proxies.splice(idx, 1); // 追加到末尾 firstGroup.proxies.push(name); }); return config; } dialer策略组复制节点版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 function main(config) { // === 配置区 === const customNodes = [ { name: \u0026#34;1024proxy-US\u0026#34;, type: \u0026#34;socks5\u0026#34;, server: \u0026#34;us.1024proxy.io\u0026#34;, port: 3000, udp: true, username: \u0026#34;2nlo5364-region-US-asn-AS7018-sid-49euBkbk-t-120\u0026#34;, password: \u0026#34;k2i3j7xq\u0026#34; // dialer-proxy 属性将在脚本末尾自动注入 }, // 可继续添加更多... // { // name: \u0026#34;CustomLabel - Backup\u0026#34;, // type: \u0026#34;socks5\u0026#34;, // server: \u0026#34;192.168.1.100\u0026#34;, // port: 1080, // udp: true, // username: \u0026#34;user\u0026#34;, // password: \u0026#34;pass\u0026#34; // } ]; // 基础初始化检查 if (!Array.isArray(config.proxies)) config.proxies = []; if (!Array.isArray(config[\u0026#34;proxy-groups\u0026#34;])) config[\u0026#34;proxy-groups\u0026#34;] = []; // === Step 1: 准备 Dialer 分组所需的数据 === // 1.1 获取所有“非策略组”的原始节点名称 (用于 dialer) const originalLeafProxies = config.proxies .filter(p =\u0026gt; ![\u0026#39;select\u0026#39;, \u0026#39;url-test\u0026#39;, \u0026#39;fallback\u0026#39;, \u0026#39;load-balance\u0026#39;, \u0026#39;relay\u0026#39;].includes(p.type)) .map(p =\u0026gt; p.name); // 1.2 [关键修复] 获取所有 Provider 的名称 (用于订阅节点) const providerNames = config[\u0026#39;proxy-providers\u0026#39;] ? Object.keys(config[\u0026#39;proxy-providers\u0026#39;]) : []; // === Step 2: 创建或更新 Dialer 策略组 === // 逻辑：Dialer 应该包含所有原始节点 + 所有订阅集合 const dialerGroup = { name: \u0026#34;dialer\u0026#34;, type: \u0026#34;select\u0026#34;, proxies: originalLeafProxies, // 手动节点 use: providerNames // [新增] 订阅集合 }; // 查找并替换，或追加 const dialerIndex = config[\u0026#34;proxy-groups\u0026#34;].findIndex(g =\u0026gt; g.name === \u0026#34;dialer\u0026#34;); if (dialerIndex !== -1) { // 保留原有的 filter/icon 等高级配置，只更新 proxies 和 use config[\u0026#34;proxy-groups\u0026#34;][dialerIndex] = { ...config[\u0026#34;proxy-groups\u0026#34;][dialerIndex], ...dialerGroup }; } else { config[\u0026#34;proxy-groups\u0026#34;].push(dialerGroup); } // === Step 3: 将自定义节点注入全局列表 === for (const node of customNodes) { // 使用 Object.assign 确保不修改原 customNodes 引用，同时注入 dialer-proxy const nodePayload = { ...node, \u0026#34;dialer-proxy\u0026#34;: \u0026#34;dialer\u0026#34; }; // 检查去重：如果同名节点已存在，更新它；不存在则 push const existingIdx = config.proxies.findIndex(p =\u0026gt; p.name === node.name); if (existingIdx !== -1) { config.proxies[existingIdx] = nodePayload; } else { config.proxies.push(nodePayload); } } // === Step 4: 将自定义节点添加到第一个 Select 分组 === if (config[\u0026#34;proxy-groups\u0026#34;].length \u0026gt; 0) { const firstGroup = config[\u0026#34;proxy-groups\u0026#34;][0]; // 仅当第一个分组是手动选择类型时才修改 if (firstGroup.type === \u0026#34;select\u0026#34;) { if (!Array.isArray(firstGroup.proxies)) firstGroup.proxies = []; customNodes.forEach(node =\u0026gt; { // 先移除旧的（如果存在），再添加到末尾 const idx = firstGroup.proxies.indexOf(node.name); if (idx !== -1) firstGroup.proxies.splice(idx, 1); firstGroup.proxies.push(node.name); }); } } return config; } SingBox 链式代理 脚本生成 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 const onGenerate = async (config) =\u0026gt; { const relayChains = [[\u0026#39;1024proxy\u0026#39;, \u0026#39;日本-优化\u0026#39;]]; // 代理链定义 const excludeReg = /selector|urltest/; // 排除分组类型 const outsMap = Object.fromEntries(config.outbounds.map((out) =\u0026gt; [out.tag, out])); // 将所有出站转换为以 tag 为键的映射 // 识别分组中包含的实际出站成员 const groupMembers = {}; for (const out of Object.values(outsMap)) { // 仅处理有效的且是分组类型的出站 if (!out?.tag || !excludeReg.test(out.type)) continue; const membersSet = new Set(); for (const candidate of Object.values(outsMap)) { // 仅处理有效的且非自身出站 if (!candidate?.tag || candidate.tag === out.tag) continue; try { // 通过 JSON 字符串包含关系判断是否为分组成员 if (JSON.stringify(out).includes(\u0026#39;\u0026#34;\u0026#39; + candidate.tag + \u0026#39;\u0026#34;\u0026#39;)) { membersSet.add(candidate.tag); } } catch (e) { // 忽略序列化错误，不影响逻辑 } } groupMembers[out.tag] = Array.from(membersSet); } // 遍历代理链并设置上游出站 relayChains.forEach((chain) =\u0026gt; { chain.forEach((tag, i, arr) =\u0026gt; { // 链的最后一个出站不需要设置上游 if (i === arr.length - 1) return; const out = outsMap[tag]; const upStream = arr[i + 1]; // 下一个出站作为当前出站的上游 if (!out) { throw `错误：当前配置内未找到出站 ${tag}`; } // 根据出站类型进行处理 if (excludeReg.test(out.type)) { // 如果是分组类型（selector 或 urltest） const members = groupMembers[tag] || []; // 检查分组是否有识别到的成员 if (!members.length) { throw `错误：分组 ${tag} 未识别到可用成员，请检查配置`; } members.forEach((mTag) =\u0026gt; { // 如果成员自身就是上游，则跳过，避免自循环 if (mTag === upStream) { Plugins.message.warn(`警告：分组 ${tag} 的成员 ${mTag} 上游与其自身一致，已跳过设置。`); return; } const mOut = outsMap[mTag]; if (!mOut) { throw `错误：当前配置内未找到出站 ${mTag}（属于分组 ${tag}）`; } // 仅为非分组且非 direct/block 类型的成员设置上游 if (!excludeReg.test(mOut.type) \u0026amp;\u0026amp; ![\u0026#39;direct\u0026#39;, \u0026#39;block\u0026#39;].includes(mOut.type)) { mOut.detour = upStream; } }); } else { // 如果是普通出站类型 // 排除 direct/block 类型，它们不可设置上游 if ([\u0026#39;direct\u0026#39;, \u0026#39;block\u0026#39;].includes(out.type)) { throw `错误：出站 ${out.tag} 类型不可设置上游`; } // 普通出站的上游不能是自身 if (tag === upStream) { throw `错误：出站 ${out.tag} 的上游不能是自身，请检查代理链配置。`; } out.detour = upStream; } }); }); return config } 流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 flowchart TD A([开始]) --\u0026gt; B[\u0026#34;初始化配置\\nrelayChains = [[\u0026#39;1024proxy\u0026#39;, \u0026#39;日本-优化\u0026#39;]]\\nexcludeReg = /selector|urltest/\u0026#34;] B --\u0026gt; C[\u0026#34;构建 outsMap:\\n以 outbounds.tag 为键的映射\u0026#34;] C --\u0026gt; D{\u0026#34;遍历所有 outbounds\\n是否为分组类型?\u0026#34;} D -- 是 --\u0026gt; E[\u0026#34;检查 JSON 是否包含其他 tag\\n收集成员到 groupMembers[tag]\u0026#34;] D -- 否 --\u0026gt; F[跳过] E --\u0026gt; G F --\u0026gt; G G[\u0026#34;完成 groupMembers 构建\u0026#34;] --\u0026gt; H{\u0026#34;遍历 relayChains\\n每条链 chain\u0026#34;} H --\u0026gt; I{\u0026#34;遍历 chain 中每个 tag\\n(i == chain.length - 1?)\u0026#34;} I -- 是 --\u0026gt; J[跳过（链尾无上游）] I -- 否 --\u0026gt; K[\u0026#34;获取当前 out = outsMap[tag]\\nupStream = chain[i+1]\u0026#34;] K --\u0026gt; L{\u0026#34;out.type 是\\nselector/urltest?\u0026#34;} L -- 是 --\u0026gt; M{\u0026#34;groupMembers[tag]\\n有成员?\u0026#34;} M -- 否 --\u0026gt; N[\u0026#34;抛出错误：\\n分组无成员\u0026#34;] M -- 是 --\u0026gt; O[\u0026#34;遍历每个成员 mTag\u0026#34;] O --\u0026gt; P{\u0026#34;mTag === upStream?\u0026#34;} P -- 是 --\u0026gt; Q[\u0026#34;警告并跳过\\n（防自循环）\u0026#34;] P -- 否 --\u0026gt; R[\u0026#34;获取 mOut = outsMap[mTag]\u0026#34;] R --\u0026gt; S{\u0026#34;mOut 是普通代理?\\n(非分组、非 direct/block)\u0026#34;} S -- 是 --\u0026gt; T[\u0026#34;设置 mOut.detour = upStream\u0026#34;] S -- 否 --\u0026gt; U[跳过] T --\u0026gt; V Q --\u0026gt; V U --\u0026gt; V L -- 否 --\u0026gt; W{\u0026#34;out.type 是\\ndirect 或 block?\u0026#34;} W -- 是 --\u0026gt; X[\u0026#34;抛出错误：\\n不可设上游\u0026#34;] W -- 否 --\u0026gt; Y{\u0026#34;tag === upStream?\u0026#34;} Y -- 是 --\u0026gt; Z[\u0026#34;抛出错误：\\n不能自指\u0026#34;] Y -- 否 --\u0026gt; AA[\u0026#34;设置 out.detour = upStream\u0026#34;] AA --\u0026gt; V V --\u0026gt; AB{\u0026#34;chain 遍历完成?\u0026#34;} AB -- 否 --\u0026gt; I AB -- 是 --\u0026gt; AC{\u0026#34;所有 relayChains\\n处理完?\u0026#34;} AC -- 否 --\u0026gt; H AC -- 是 --\u0026gt; AD[\u0026#34;返回修改后的 config\u0026#34;] J --\u0026gt; AB N --\u0026gt; AE([结束 - 报错]) X --\u0026gt; AE Z --\u0026gt; AE AD --\u0026gt; AF([结束 - 成功]) 代理检查 命令行 国内 1 2 3 4 curl cip.cc curl myip.ipip.net curl ddns.oray.com/checkip curl ip.3322.net 国外 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 curl ip-api.com curl \u0026#34;ip-api.com/line?fields=query,country,city,isp\u0026#34; curl ip-api.com/json curl wtfismyip.com/json curl tnx.nl/ip curl api.ipify.org curl checkip.amazonaws.com curl eth0.me curl icanhazip.com curl ident.me curl ifconfig.me curl ip.dnsexit.com curl ip.sb curl ipecho.net/plain curl l2.io/ip curl myexternalip.com/raw curl myip.dnsomatic.com curl wgetip.com curl whatismyip.akamai.com v4v6 1 2 3 4 5 6 7 8 curl ipv4.icanhazip.com curl ipv6.icanhazip.com curl 4.ifconfig.me curl 6.ifconfig.me curl v4.ident.me curl v6.ident.me curl 4.ipw.cn curl 6.ipw.cn 神经 1 curl ipinfo.io/ip ","date":"2026-01-22T09:05:58+08:00","permalink":"https://windovec.github.io/redeem/p/proxy/","title":"代理"},{"content":"主题 One Dark Theme One Dark Theme Theme for JetBrains IDEs | JetBrains Marketplace\n","date":"2025-12-26T14:29:57+08:00","permalink":"https://windovec.github.io/redeem/p/idea-base/","title":"IDEA的安装与配置"},{"content":"初识Java IDEA 快捷键 Ctrl+D：复制粘贴 默认行\nCtrl+Y：删除行\nCtrl + ALT + L：格式化代码\nALT + SHIFT + ↑, ALT + SHIFT + ↓ ：上下移动当前代码\nCtrl + / , Ctrl + Shift + /：对代码进行注释\nALT + P：千问强制生成\nCtrl + ALT + M：提取方法\nCtrl + ALT + V：引入变量\nCtrl + ALT + C：引入参数\nCtrl + ALT + P：引入形参\nCtrl + ALT + P：引入形参\nAlt + Insert：快速生成器\n项目结构 项目 - 模块 - 包 - 类\n项目 - 包 - 类\n项目目录下的子目录，每个模块有自己的src（源代码）、resources（资源文件）和配置（如pom.xml），可通过 \u0026ldquo;Project Structure\u0026rdquo; 管理模块依赖。\n注释 单行\n多行\n文档\n定义类 文件名和类名相同\n1 2 3 4 5 6 public class helloworld{ // 程序入口（psvm） public static void main(String[] args){ System.out.println(\u0026#34;Hello World\u0026#34;); } } Java核心语法 字面量 字面量类型 说明 程序中的写法 整数 不带小数的数字 666，-88 小数 带小数的数字 13.14，-5.21 字符 必须使用单引号，有且仅能一个字符 ‘A’，‘0’， ‘我’ 字符串 必须使用双引号，内容可有可无 “HelloWorld”，“黑马程序员” 布尔值 布尔值，表示真假，只有两个值：true，false true 、false 空值 一个特殊的值，空值 值是：null 变量 可以一次多个变量\n成员变量（字段）：可以不赋初值，系统会提供默认值\n局部变量：使用前必须赋初值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class VariableExample { // 成员变量，可不初始化 private int instanceVar; // 默认为0 private String strVar; // 默认为null private boolean flag; // 默认为false public void method() { int a = 10, b = 20, c = 20,d = 20; int e, f, g; e = f = g = 10; // 局部变量，必须初始化后使用 int localVar; // 声明但未初始化 // System.out.println(localVar); // 编译错误！ localVar = 10; // 必须先赋值 System.out.println(localVar); // 正确使用 } } 数据类型 基本数据类型 四类八种 数据类型 关键字 内存占用 取值范围 整数 byte 1 负的2的7次方 ~ 2的7次方-1(-128~127) short 2 负的2的15次方 ~ 2的15次方-1(-32768~32767) int 4 负的2的31次方 ~ 2的31次方-1 long 8 负的2的63次方 ~ 2的63次方-1 浮点数 float 4 1.401298e-45 ~ 3.402823e+38 double 8 4.9000000e-324 ~ 1.797693e+308 字符 char 2 0-65535 布尔 boolean 1 true，false 如果要定义一个 long 类型的变量，在数据值的后面需要加上 L 后缀。(大小写都可以，建议大写) 如果要定义一个 float 类型的变量，在数据值的后面需要加上 F 后缀。(大小写都可以） 引用数据类型 标识符 命名 必须由数字、字母、下划线_、美元符号$组成 数字不能开头 不能是关键字 区分大小写的 小驼峰命名法 适用于变量名和方法名\n如果是一个单词，那么全部小写，比如：name 如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge 大驼峰命名法 适用于类名\n如果是一个单词，那么首字母大写。比如：Demo、Test。 如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld 键盘录入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.windove.hello; //1.导包 import java.util.Scanner; public class HelloWorld{ public static void main(String[] args){ //2.创建对象 Scanner sc = new Scanner(System.in); //3.接收 int int i = sc.nextInt(); //4. 接收字符串 String str = sc.next(); //5.接收 double double d = sc.nextDouble(); //6.接收 boolean boolean b = sc.nextBoolean(); //7.接收 float float f = sc.nextFloat(); //关闭 sc.close(); } } AI技巧-1 alt+enter：修改错误\nalt+p：强制生成代码\n运算 练习-进制拆分 1 2 3 4 5 6 7 int ones = number % 10; int tens = number / 10 % 10; int hundreds = number / 100 % 10; int hours = seconds / 3600; //3661 / 3600 int min = seconds % 3600 / 60; int second = seconds % 3600 % 60; 类型转换 隐式转换 也叫自动类型提升，把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量\nNote 取值范围从小到大的关系：\nbyte short int long float double\n触发时机：\n不同类型的数据进行计算，默认采取隐式转换，Java自动转换，无需我们写代码 提升规则：\n**规则一：**如有byte short类型的数据，先提升为int类型 **规则二：**把取值范围小的提升为取值范围大的，再进行运算 强制转换 1 2 3 4 5 6 7 public class OperatorDemo2 { public static void main(String[] args) { double a = 12.3; int b = (int) a; System.out.println(b);//12 } } Note 强制转换有可能会导致数据发生错误。（数据的精度丢失）\n字符串的+操作 当连续进行+操作时，从左到右逐个执行的 有字符串参与 -\u0026gt; 拼接操作 字符的+操作 ASCII码\n自增自减运算符 先加后用，先用后加\n赋值运算符 =\n扩展赋值运算符 +=、-=、*=、/=、%=\nNote 扩展赋值运算符隐含强制转换（以被复制对象类型为准）。\n关系运算符 == != \u0026gt; \u0026gt;= \u0026lt; \u0026lt;=\n逻辑运算符 \u0026amp; | !\n\u0026amp;\u0026amp; || （短路，类似C，省劲）\n三元运算符 又叫做：三元表达式或者问号冒号表达式。\n格式：关系表达式 ？ 表达式1 ：表达式2 ;\n计算规则：\n计算关系表达式的值。 如果关系表达式的值为真，那么执行表达式1。 如果关系表达式的值为假，那么执行表达式2。 Note 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。\n运算符的优先级 流程控制语句 判断语句 1 2 3 4 5 6 7 8 9 10 if (关系表达式1) { 语句体1; } else if (关系表达式2) { 语句体2; } ... else { 语句体n+1; } 选择语句 Note 选项个数有限优先使用switch\n1 2 3 4 5 6 7 8 9 10 11 12 switch (表达式) { case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break; } 结果可以为字符 / byte short int / 枚举 / 字符串，不能小数，不能 long\n结果不能变量\ndefault的位置和省略情况\ndefault可以放在任意位置，也可以省略\ncase穿透\n不写break会引发case穿透现象，执行每个判断；成功或遇到default则执行当前和后续每个case，直到出现break\n利用：\n1 2 3 4 5 6 7 8 9 switch (month){ case 12: case 1: case 2: System.out.println(\u0026#34;冬季\u0026#34;); break; case3: ... } 箭头标签：一条指令\nNote 在Java的switch表达式中，不能混合使用不同类型的case语法。箭头语法和花括号语法\ncase 可以多个值\n可以返回结果\nyield 关键字标志返回结果\n在 case \u0026ldquo;value\u0026rdquo;: { \u0026hellip; } 结构中替代 return\n1 2 3 4 5 6 7 8 9 10 int result = switch (operator) { case \u0026#34;+\u0026#34; -\u0026gt; a + b; /* case \u0026#34;+\u0026#34;:{ yield a+b; }*/ case \u0026#34;-\u0026#34; -\u0026gt; a - b; case \u0026#34;*\u0026#34; -\u0026gt; a * b; case \u0026#34;/\u0026#34; -\u0026gt; a / b; default -\u0026gt; 0; }; 循环结构 for循环 知道循环次数或者循环范围\n1 2 3 for (初始化语句;条件判断语句;条件控制语句) { 循环体语句; } while循环 不知道循环次数或者循环范围，知道循环的结束条件\n1 2 3 4 5 初始化语句; while(条件判断语句){ 循环体; 条件控制语句; } do\u0026hellip;while循环 1 2 3 4 5 初始化语句; do{ 循环体; 条件控制语句; }while(条件判断语句); 无限循环 for格式 1 2 3 for(;;){ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); } while格式 常用\n1 2 3 while(true){ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); } do\u0026hellip;while格式 1 2 3 do{ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); }while(true); 条件控制语句 break 不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //1.吃1~5号包子 for (int i = 1; i \u0026lt;= 5; i++) { System.out.println(\u0026#34;在吃第\u0026#34; + i + \u0026#34;个包子\u0026#34;); //2.吃完第三个的时候就不吃了 if(i == 3){ break;//结束整个循环。 } //检验输入 while (true){ System.out.println(\u0026#34;请输入当前人物受到的伤害：\u0026#34;); hurt = sc.nextInt(); // 判断是否符合当前的需求 if (hurt \u0026gt; 0) { break; }else{ System.out.println(\u0026#34;当前收到了伤害不能为负数\u0026#34;); } } //找质数 int count = 0; for (int i = 2; i \u0026lt;= number - 1; i++) { // 100 2 - 99 if (number % i == 0) { count++; // 只要找到了一个数字能被number整除，那么number就不是质数，后面的数据就没有必要再判断了 // System.out.println(\u0026#34;不是\u0026#34;); // 如果在这个范围中我找到了一个能被number整除， break; } } continue 不能单独存在的。只能存在于循环当中。表示：跳过本次循环，继续执行下次循环。\n1 2 3 4 5 6 7 8 9 //1.吃1~5号包子 for (int i = 1; i \u0026lt;= 5; i++) { //2.第3个包子有虫子就跳过，继续吃下面的包子 if(i == 3){ //跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。 continue; } System.out.println(\u0026#34;在吃第\u0026#34; + i + \u0026#34;个包子\u0026#34;); } Random 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.example.random // 定位Random类的位置 import java.util.Random; public class Test1 { public static void main(String[] args) { // 1. 找到Random这个类 Random r = new Random(); // 2. 生成一个随机数 // (了解)第一种写法：默认是在int的取值范围之内获取随机数 int number = r.nextInt(); // (重要)第二种写法：一个int参数，表示随机的最大值，不包含 // 1~100 int number = r.nextInt(100) + 1; // (重要)第三种写法：两个int参数，范围是a ~ b，包含a，不包含b JDK17 // 1~100 int number = r.nextInt(1, 101); } } 循环嵌套 for、while 可以互相嵌套\n补充知识 制表符 \\t\n在IDEA中，在前面的字符后面补1-4个空格，让这个整体（空格为分界）的长度凑成4的整数倍\n数组 静态初始化 完整格式\n1 数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...}; 简化格式\n1 数据类型[] 数组名 = {元素1，元素2，元素3，元素4...}; 数组一旦创建之后，长度不能发生变化。\n动态初始化 1 数据类型[] 数组名 = new 数据类型[数组的长度]; 数组的默认初始化值： 整数类型：0 小数类型：0.0 布尔类型：false 字符类型：\u0026rsquo;\\u0000' 引用类型：null 访问 数组名[索引]; 索引一定是从0开始的。 连续不间断。 逐个+1增长。 数组的遍历 数组的长度：数组名.length;\n1 2 3 for(int i = 0; i \u0026lt; arr.length; i++){ sout(arr[i]); } 数组常见问题 当访问了数组中不存在的索引，就会引发索引越界异常。 数组练习 练习5：有序数组中去除重复元素（快慢指针）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test6 { public static void main(String[] args) { // 给定义一个递增有序数组，去除其中重复元素 int[] arr = {1, 1, 2, 2, 2, 2, 3, 3, 3, 3}; // 1. 定义两个指针 int slow = 0; int fast = 1; // 2.利用循环不断的移动快慢指针,找不重复的元素 while (fast \u0026lt; arr.length){ // 判断两个指针指向数据是否相同 if(arr[slow] != arr[fast]){ slow++; arr[slow] = arr[fast]; } fast++; } // 3.输出结果 for (int i = 0; i \u0026lt;= slow; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } } 待补充 练习一下排序算法\n方法 注意此处为测试类，所以main函数和自定义添加的函数都带有 static 关键字，可以不创建对象直接通过类名调用\n无参数方法定义和调用 定义格式\n1 2 3 public static void 方法名 ( ) { // 方法体; } 调用格式\n1 方法名(); 带参数方法定义和调用 定义格式\n1 2 3 public static void 方法名 (类型1 参数1, 类型2 参数2, 类型3 参数3...) { 方法体; } 调用格式：\n1 2 方法名(参数)； 方法名(参数1,参数2); 形参和实参 数量 类型 顺序 对应\n带返回值方法的定义和调用 定义格式\n1 2 3 public static 数据类型 方法名 ( 参数 ) { return 数据 ; } 调用格式：\n1 2 方法名 ( 参数 ) ; 数据类型 变量名 = 方法名 ( 参数 ) ; 注意事项 方法不能嵌套定义\nvoid表示无返回值，可以省略return，也可以单独的书写return，后面不能加数据\n方法重载 概念：方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同，或者顺序 Note 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\n重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\n当利用隐式转换自动匹配时，如果出现两个符合程度相同的方法，会报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class MethodTest { public static void main(String[] args) { System.out.println(compare(10, 20)); } public static boolean compare(int a, double b) { System.out.println(\u0026#34;int\u0026#34;); return a == b; } public static boolean compare(double a, int b) { System.out.println(\u0026#34;byte\u0026#34;); return a == b; } } 综合练习 练习2：数组遍历\n补充 print\nSystem.out.println(“内容”); 输出内容并换行 System.out.print(“内容”); 输出内容不换行 System.out.println(); 起到换行的作用 练习3：计算快递邮费\n待补充 fail fast原则\n代码示例1中计算超重部分重复代码了\n代码示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class ExpressCostCalculator { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); double weight; // 输入重量并验证 while (true) { System.out.print(\u0026#34;请输入快递重量(kg): \u0026#34;); weight = scanner.nextDouble(); if (weight \u0026lt;= 0) { System.out.println(\u0026#34;重量必须大于0，请重新输入！\u0026#34;); } else { break; } } // 计算运费 double cost = calculateCost(weight); System.out.println(\u0026#34;快递重量:\u0026#34; + weight); System.out.println(\u0026#34;运费:\u0026#34; + cost); } // 计算总费用 public static double calculateCost(double weight) { double baseCost = 10.0; // 首重1kg费用 if (weight \u0026lt;= 1.0) {// 首重1kg以内 return baseCost; } else if (weight \u0026gt; 1.0 \u0026amp;\u0026amp; weight \u0026lt;= 6.0) {// 总重1-6kg（超出1-5kg） // 1. 计算超出部分的重量 double overWeight = weight - 1.0; // 2. 计算超出部分的价格 int fullKg = ceil(overWeight); return baseCost + fullKg * 2.0; } else {// 总重超过6kg（超出5kg以上） // 1. 计算前6kg的价格 double cost = baseCost + 5 * 2.0; // 2. 计算超出6kg的部分（向上取整） double overWeight = weight - 1.0; int fullKg = ceil(overWeight); // 3. 剩余部分按1.5元计算 if (fullKg \u0026gt; 5) { cost += (fullKg - 5) * 1.5; } return cost; } } // 小数向上取整 // 1.1 -\u0026gt; 2 // 1.8 -\u0026gt; 2 public static int ceil(double weight) { // 备注：此时无需考虑负数，因为在main方法中已经判断过，以后本方法可以用Math里面的ceil替代 // 如果是整数，直接返回 if(weight % 1 == 0){ return (int)weight; } // 如果是小数，则向上取整 return (int) (weight + 1); } } 代码示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class ExpressCostCalculator { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); double weight; // 输入重量并验证 while (true) { System.out.print(\u0026#34;请输入快递重量(kg): \u0026#34;); weight = scanner.nextDouble(); if (weight \u0026lt;= 0) { System.out.println(\u0026#34;重量必须大于0，请重新输入！\u0026#34;); } else { break; } } // 计算运费 double cost = calculateTotalCost(weight); System.out.println(\u0026#34;快递重量: \u0026#34; + weight); System.out.println(\u0026#34;运费:\u0026#34; + cost); } // 计算总费用 public static double calculateTotalCost(double weight) { double baseCost = 10.0; // 首重1kg费用 if (weight \u0026lt;= 1.0) { return baseCost; } // 计算超出部分重量（向上取整） double overWeight = weight - 1.0; int ceilKg = (int) Math.ceil(overWeight); // 计算超出部分费用 double overCost = calculateOverCost(ceilKg); return baseCost + overCost; } // 计算超出部分费用 // 下面代码采取了fail fast原则，也是实际开发首选。 // 即：每段代码负责独立功能，互不影响，遇到问题或者得到结果立刻结束。 // google、Oracle鼓励此风格 public static double calculateOverCost(int kg) { // 无超重 if (kg \u0026lt;= 0) { return 0.0; } // 超重 1kg ~ 5kg if (kg \u0026lt;= 5) { return kg * 2.0; } // 超重5kg（前5kg按2元/kg，剩余部分按1.5元/kg） return 5 * 2.0 + (kg - 5) * 1.5; } } Java的运行原理 运行机制 java文件（源文件）-\u0026gt; 编译 -\u0026gt; class文件（字节码文件）\nJava的虚拟机英文名称（Java Virtual Machine），简称：JVM。\n内存和内存地址 内存：也叫做随机访问存储（Random Access Memory，简称RAM）是计算机中的一种主要存储设备。它可以快速读取和写入数据。\n32位的操作系统\n内存地址以32位的二进制表示，其实就是32位的01，表现形式如下\n64位的操作系统\n内存地址以32位的二进制表示，其实就是64位的01，表现形式如下：\n进制标志\n不同的进行在书写的时候为了避免混淆，都有前缀\n二进制前缀0b，写作0b110，表示110是二进制的\n八进制前缀0，写作0110，表示110是八进制的\n十进制无前缀，写作110，表示110是十进制的\n十六进制前缀0x，写作0x110，表示110是十六进制的\n内存分配 栈内存\n方法运行，方法调用\n堆内存\n所有线程共享，new / 存储对象、数组、字符串常量池。\n方法区\nJDK7永久代实现，JDK8+元空间实现，从虚拟机内部移到本地内存。存储字节码信息、常量、静态变量。\n使用到某个 类 / 方法 时，将内容转移到方法区，字节码形式\n本地方法栈\n调用本地Native方法。暂时用不上，不需要记忆。\n程序计数\n每个线程独立、记录当前线程执行的字节码指令地址（行号）。暂时用不上，不需要记忆。\n参数传递 对于基本类型（如 int, double 等）\n传递的是实际值的拷贝。\n对于引用类型（如数组、对象）\n传递的是引用的拷贝（即指向同一个对象的地址副本）。\n数组 形参 int[] arr\n其他函数通过形参可以修改实参对应的数组，但是原来的 arr 中保存的内存地址不会被 arr =xxx 修改\n算法综合练习 接雨水\n思路\n从左看\n从右看\n取交集\n去底座\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package com.itheima.test; public class Test5 { public static void main(String[] args) { /* 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：下面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水） */ // 1. 定义数组 int[] arr = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; // 2. 从左往右遍历,记录雨水 + 柱子的面积总和 // 2.1 定义数组记录从左往右看的数据 int[] leftMax = new int[arr.length]; // 2.2 定义第三方变量temp，记录当前最高的柱子 int temp = arr[0]; // 2.3 遍历数组 for (int i = 0; i \u0026lt; arr.length; i++) { // 判断 temp 数组里面的数据 if(temp \u0026gt; arr[i]){ leftMax[i] = temp; }else{ leftMax[i] = arr[i]; temp = arr[i]; } } // 3. 从右往左遍历,记录雨水 + 柱子的面积总和 int[] rightMax = new int[arr.length]; temp = arr[arr.length - 1]; for (int i = arr.length - 1; i \u0026gt;= 0; i--) { if(temp \u0026gt; arr[i]){ rightMax[i] = temp; }else{ rightMax[i] = arr[i]; temp = arr[i]; } } // 4. 取交集 int[] result = new int[arr.length]; for (int i = 0; i \u0026lt; rightMax.length; i++) { // leftMax[i]: 从左到右数组中的数据 // rightMax[i]: 从右到左数组中的数据 if(leftMax[i] \u0026lt; rightMax[i]){ result[i] = leftMax[i]; }else{ result[i] = rightMax[i]; } } // 5. 求和 int sum = 0; for (int i = 0; i \u0026lt; result.length; i++) { sum = sum + result[i]; } // 6. 去掉柱子的面积 for (int i = 0; i \u0026lt; arr.length; i++) { sum = sum - arr[i]; } System.out.println(sum); } } 大乐透\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 public class Test6 { public static void main(String[] args) { // 1. 利用Random随机,生成彩票号码 int[] lotteryNumber = createLotteryNumber(); printLotteryNumber(lotteryNumber); // 2. 利用Scanner模拟购买彩票 int[] mylotteryNumber = buyLotteryNumber(); printLotteryNumber(mylotteryNumber); // 3.判断中奖 // 判断中了几个前区 (红球) // 判断中了几个后区 (蓝球) getWinnerNumber(lotteryNumber, mylotteryNumber); } // 作用:判断arr2里面的数据,在arr1中出现了几次 // arr1: 真正的彩票号码 // arr2: 用户购买的彩票号码 public static void getWinnerNumber(int[] arr1, int[] arr2) { // 判断前区中了几个球 int count1 = getCount(arr1, arr2, 0, 4); // 判断后区中了几个球 int count2 = getCount(arr1, arr2, 5, 6); // 判断中了几等奖 if (count1 == 5 \u0026amp;\u0026amp; count2 == 2) { System.out.println(\u0026#34;恭喜你,中奖了一等奖\u0026#34;); } else if (count1 == 5 \u0026amp;\u0026amp; count2 == 1) { System.out.println(\u0026#34;恭喜你,中奖了二等奖\u0026#34;); } else if (count1 == 5 \u0026amp;\u0026amp; count2 == 0 || count1 == 4 \u0026amp;\u0026amp; count2 == 2) { System.out.println(\u0026#34;恭喜你,中奖了三等奖\u0026#34;); } else if (count1 == 4 \u0026amp;\u0026amp; count2 == 1 || count1 == 3 \u0026amp;\u0026amp; count2 == 2) { System.out.println(\u0026#34;恭喜你,中奖了四等奖\u0026#34;); } else if (count1 == 4 \u0026amp;\u0026amp; count2 == 0 || count1 == 3 \u0026amp;\u0026amp; count2 == 1 || count1 == 2 \u0026amp;\u0026amp; count2 == 2) { System.out.println(\u0026#34;恭喜你,中奖了五等奖\u0026#34;); } else if (count1 == 3 \u0026amp;\u0026amp; count2 == 0 || count1 == 2 \u0026amp;\u0026amp; count2 == 1 || count1 == 1 \u0026amp;\u0026amp; count2 == 2 || count1 == 0 \u0026amp;\u0026amp; count2 == 2) { System.out.println(\u0026#34;恭喜你,中奖了六等奖\u0026#34;); } else { System.out.println(\u0026#34;恭喜你,没有中奖\u0026#34;); } } // 判断前区或者后区中了几个球 public static int getCount(int[] arr1, int[] arr2, int start, int end) { int count = 0; for (int i = start; i \u0026lt;= end; i++) { // 0 1 2 3 4 // arr2[i] 到arr1判断,是否存在 boolean flag = contains(arr2[i], arr1, start, end); // 如果当前的数字已存在, 表示中了一个号码 if (flag) { count++; } } // 当循环结束之后,我就知道了,在start ~ end之间,中了几个号码 return count; } public static int[] buyLotteryNumber() { // 1. 创建一个数组 int[] arr = new int[7]; // 2. 利用Scanner模拟购买彩票,1 ~ 35 选5个号码（唯一） Scanner sc = new Scanner(System.in); for (int i = 0; i \u0026lt; 5; ) { System.out.println(\u0026#34;请输入第\u0026#34; + (i + 1) + \u0026#34;个彩票号码:\u0026#34;); int number = sc.nextInt(); // 范围 if (number \u0026lt; 1 || number \u0026gt; 35) { System.out.println(\u0026#34;当前彩票号码不在范围当中,请重新选择~\u0026#34;); continue; } // 唯一 boolean flag = contains(number, arr, 0, 4); if (flag) { System.out.println(\u0026#34;当前彩票号码已存在,请重新选择~\u0026#34;); continue; } // 如果代码能执行到这里,表示number是在范围当中的,而且数据是唯一的\\ arr[i] = number; i++; } // 3. 利用Scanner模拟购买彩票,1~ 12 选2个号码（唯一） for (int i = 0; i \u0026lt; 2; ) { System.out.println(\u0026#34;请输入第\u0026#34; + (i + 1) + \u0026#34;个彩票号码:\u0026#34;); int number = sc.nextInt(); // 范围 if (number \u0026lt; 1 || number \u0026gt; 12) { System.out.println(\u0026#34;当前彩票号码不在范围当中,请重新选择~\u0026#34;); continue; } // 唯一 boolean flag = contains(number, arr, 5, 6); if (flag) { System.out.println(\u0026#34;当前彩票号码已存在,请重新选择~\u0026#34;); continue; } arr[i + 5] = number; i++; } return arr; } public static int[] createLotteryNumber() { // 1. 创建数组 int[] arr = new int[7]; // 2. 利用Random生成彩票号码,先生成前区的五个号码,1 ~ 35 选5个号码（唯一） Random r = new Random(); for (int i = 0; i \u0026lt; 5; ) { int number = r.nextInt(1, 36); // 在前面的五个数据中,判断number是否唯一 0 ~ 4 boolean flag = contains(number, arr, 0, 4); if (!flag) { arr[i] = number; i++; } } // 3. 利用Random生成彩票号码,先生成后区的五个号码,1~ 12 选2个号码（唯一） for (int i = 0; i \u0026lt; 2; ) { int number = r.nextInt(1, 13); // 在后面两个数据中,判断number是否唯一 5 ~ 6 boolean flag = contains(number, arr, 5, 6); // 判断 if (!flag) { arr[i + 5] = number; i++; } } return arr; } public static boolean contains(int number, int[] arr, int start, int end) { for (int i = start; i \u0026lt;= end; i++) { if (arr[i] == number) { return true; } } return false; } public static void printLotteryNumber(int[] arr) { System.out.print(\u0026#34;[\u0026#34;); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == arr.length - 1) { System.out.print(arr[i]); } else { System.out.print(arr[i] + \u0026#34;, \u0026#34;); } } System.out.println(\u0026#34;]\u0026#34;); } } 面向对象 定义、创建、赋值 类\n1 2 3 4 public class 类名 { 属性类型 属性名; ... } 创建对象\n1 类名 对象名 = new 类名(参数) 赋值\n1 对象名.属性名 = 值; 细节 成员变量和属性\n成员变量是 Java 术语，指的是定义在类中、方法外的变量（即非局部变量）。\n根据是否使用 static 修饰，可分为实例变量（无）、类变量（有） 菜鸟教程中 属性是面向对象设计术语，通常指一个对象所拥有的状态或特征\n在 Java 语境中属性 ≈ 具有 getter/setter 方法的私有成员变量\nJavaBean类\nJavaBean 类可以写变量和行为（方法），Javabean 类的方法不加 static\nJavaBean 规范中的“属性”定义： 一个私有成员变量（如 private String name;） 对应的公共 getter 和 setter 方法（如 getName(), setName(...)） 这样的组合被称为一个 property （属性） 其他\n字段（Field） = 成员变量\n在 Java 官方文档中，“field” 和 “member variable” 基本同义。 public 成员变量算不算“属性”？\n技术上可以算，但不符合封装原则。JavaBean 规范要求属性通过 getter/setter 访问，所以通常“属性”隐含了封装性。 只读属性？\n如果只有 getter 没有 setter（如 getAge() 但无 setAge()），仍算作一个只读属性。 成员变量是 Java 代码中的实际变量；属性是面向对象设计中表示对象状态的逻辑概念，通常由私有成员变量及其 getter/setter 方法共同构成。\n测试类\n数据安全 private 关键字\n权限修饰符，默认 public\n只能本类中访问（被类中的方法访问）\nget/set 方法\n创建 public 方法，限制赋值范围\n实例 类的选择\n创建对象时，Java 可以检测到相同项目中所有 package 的类，如果要使用其他 package 的类，则需要导入\n1 import 包名.类名 使用本包内的类，不需要 import\n就近原则和 this 关键字 就近原则\n当局部变量和成员变量重名时\n方法的变量（包括形参）\n成员变量\nthis 关键字\n使用 this 关键名代表成员的变量\n不重复时可以不用 this\n1 this.属性名 构造方法 定义\n1 2 3 修师傅 类名(参数){ 方法体; } 1 2 3 4 5 6 7 8 // 构造方法 public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } 特点\n方法名和类名相同，区分大小写 没有返回值类型，void 不写 可以重载 注意事项\n只要有构造，系统不默认 习惯写出无参构造和带全部参数的构造方法 面向对象原理 内存分配 步骤\n加载 class 文件 申明局部变量 堆中开辟空间 默认初始化 显示初始化\n定义类的时候就进行赋值 构造方法初始化 赋值地址值 位置\n实例变量（地址）存放在栈内存 实例的具体数据存放在堆内存 方法出栈，具备变量出堆\n参数传递 传递对象的内存地址，类似数组\nthis本质 所在方法调用者的地址（保存在栈内存中，指向堆地址）\n面向对象进阶 static 关键字 修饰成员变量和成员方法\n修饰成员变量 变为静态变量，被该类所有对象共享\n类名调用\n1 2 3 4 5 6 7 8 public class Student{ String name; int age; static String teachername; } Student stu1 = new Student(); Student.teachername = \u0026#34;张老师\u0026#34;; 对象名调用\n不推荐\n1 stu1.teachername = \u0026#34;张老师\u0026#34;; 修饰成员方法 工具类\n不描述事物，没有main方法 类名见名知意 私有化构造方法 方法定义为静态（可以直接通过类名调用） 1 2 3 4 5 6 public class ArrayUitl{ private ArrayUitl(){} public static void printArr(int[] arr){ ... } } static 内存分配 JDK8 以前：方法区中的静态区存储静态变量\nJDK8 开始，存放在堆内存，随着类加载，优先于对象\n堆内存中的对象空间中记录着静态区的内存地址\n方法区和静态区一般不会自动释放\nstatic 注意事项 结合内存分配先后顺序理解\n静态方法只能访问静态变量和其他静态方法 非静态方法可以访问静态和非静态 静态方法中没有 this 关键字 final 关键字（部分-修饰变量） 特点\n最终、不可变，修饰变量、类、方法\n只能赋值一次，定义时需要赋值\n常量名字大写，空格用下划线取代\n修饰基本数据类型（四类八种byte short int long float double char boolean）\n变量里记录的数据无法修改\n修饰引用数据类型\n变量指向的内存（堆）地址无法修改\n枚举 特殊的JavaBean类，类的对象个数有限，适用于状态等，直接调用，不需要创建对象 -\u0026gt; 枚举类的构造方法默认使用private修饰\n定义格式\n1 2 3 4 5 public enum 枚举类名{ 枚举项1, 枚举项2, ...; 属性 行为 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.itheima.enumtest; public enum OrderState { // 在枚举类的第一行，把所有的对象都罗列出来了 PAYMENT_PENDING(\u0026#34;待支付\u0026#34;), PROCESSING(\u0026#34;处理中\u0026#34;), SHIPPED(\u0026#34;已发货\u0026#34;), OUT_FOR_DELIVERY(\u0026#34;配送中\u0026#34;), DELIVERED(\u0026#34;已送达\u0026#34;), CANCELLED(\u0026#34;已取消\u0026#34;); private String name; // 枚举类的构造方法默认使用private修饰，就算不写，虚拟机也会加上private OrderState(String name) { System.out.println(\u0026#34;看看我执行了吗？\u0026#34; + name); this.name = name; } public String getName() { return name; } } 使用\n直接输出：枚举量名 ```java package com.itheima.enumtest; public class EnumTest1 { public static void main(String[] args) { /* 电商项目中，订单的状态只有以下6种，请编写代码实现。 待支付 PAYMENT_PENDING 处理中 PROCESSING 已发货 SHIPPED 配送中 OUT_FOR_DELIVERY 已送达 DELIVERED 已取消 CANCELLED */ // 获取枚举类的对象 // 细节： // 所有的枚举项，默认使用public static final修饰的 OrderState o1 = OrderState.PAYMENT_PENDING; System.out.println(o1); //PAYMENT_PENDING System.out.println(o1.getName()); //待支付 // 匹配 switch (o1){ case PAYMENT_PENDING -\u0026gt; System.out.println(\u0026quot;待支付状态\u0026quot;); case PROCESSING -\u0026gt; System.out.println(\u0026quot;处理中\u0026quot;); case SHIPPED -\u0026gt; System.out.println(\u0026quot;已发货\u0026quot;); case OUT_FOR_DELIVERY -\u0026gt; System.out.println(\u0026quot;配送中\u0026quot;); case DELIVERED -\u0026gt; System.out.println(\u0026quot;已送达\u0026quot;); case CANCELLED -\u0026gt; System.out.println(\u0026quot;已取消\u0026quot;); } } } ``` 注意事项\n每一个枚举项，都是该枚举类的对象，每一个对象都是通过构造方法创建出来的\n创建一个枚举变量，会执行 n 次构造函数 枚举项在底层其实就是常量，默认用 public static final 修饰，public static -\u0026gt; 类名访问\n对象和方法都是 private\n枚举类的第一行上必须是枚举项，枚举项之间用逗号隔开，以分号作为结尾\n枚举类的构造方法必须是 private 修饰，不让外界创建本类的对象\n编译器会给枚举类新增两个默认存在的方法：values()、valueOf ()\nvalues()\n返回包含所有枚举项的数组\n1 OrderState[] os = OrderState.values(); valueOf(String name)\n返回 名为 name 的一个枚举项\n1 2 3 OrderState o2 = OrderState.valueOf(\u0026#34;SHIPPED\u0026#34;); System.out.println(o2); System.out.println(o2.getName()); 面向对象高级 面向对象三个特征：封装、继承、多态\n继承 格式\n1 public class 子类 extends 父类 {} 别称\n子类：派生类 父类：基类 / 超类 继承的特点 只支持单继承，不支持多继承，但支持多层继承\n父类\n直接父类\n简洁父类\n顶级父类：Object\n默认继承 extends Object\n继承中成员变量 书写规则：相同属性抽取到父类\n调用规则：就近原则\n找方法 找本类成员：强制使用 -\u0026gt; this 找父类：强制使用 -\u0026gt; super 最多访问到父类 继承中成员方法 方法重写\n重写父类方法时申明需要完全一致 使用 @Override 注解 重写时可以通过 super 调用父类方法 综合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.itheima.oopextendstest11; public class BachelorStudent extends Student{ // 私有化成员变量 不写 没有独有的 // 空参构造 // 带全部参数的构造（间接父类 + 直接父类 + 自己） public BachelorStudent() { } public BachelorStudent(String name, int age, String grade) { super(name, age, grade); } // get / set // 重写学习的方法 @Override public void study() { System.out.println(\u0026#34;本科的同学正在攻读本科内容~\u0026#34;); } } 继承的内存结构/字节码文件 构造方法：不能被子类继承，可以利用 super 关键字调用\n成员变量：可以被子类继承，private 私有的也可以，但是私有的无法直接调用\n成员方法：\n虚方法可以被继承\nfinal 修饰的最终方法不能被继承，可以被调用\n编译期：一级一级往上找，遍历整个继承链，确定要调用的方法在A类里面，记录该方法的地址 运行期：直接运行编译时确定的方法，虽然降低了编译的速度，但是运行的速度会得到保证 static 修饰的静态方法不能被继承，可以被调用\n编译期：一级一级往上找，遍历整个继承链，确定要调用的方法在A里面将对象调用方法直接修改为类名调用方法 运行期：直接运行 private 修饰的私有方法不能被继承，不能被调用\n方法重写：子类替换虚方法表里面方法的地址值\n附录 调用 同一类中调用方法 在同一个类中调用方法是最简单的情况。你可以直接通过方法名来调用其他方法。\n1 2 3 4 5 6 7 8 9 public class MyClass { public void method1() { method2(); // 调用本类中的其他方法 } public void method2() { System.out.println(\u0026#34;This is method2.\u0026#34;); } } 同一包中调用方法 当两个类位于同一个包中时，它们可以访问对方的所有非私有成员（public、protected、默认访问权限）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // MyClass.java package com.example; public class MyClass { public void method() { System.out.println(\u0026#34;This is method in MyClass.\u0026#34;); } } // AnotherClass.java package com.example; public class AnotherClass { public static void main(String[] args) { MyClass mc = new MyClass(); mc.method(); // 直接调用同一包中的方法 } } 不同包中调用方法\n在不同包中，类之间的访问权限受到限制。以下是一些常见的调用方式：\n使用import语句\n通过import语句，可以在任何地方直接使用其他包中的类。\n1 2 3 4 5 6 7 8 import com.example.MyClass; public class Main { public static void main(String[] args) { MyClass mc = new MyClass(); mc.method(); // 直接调用不同包中的方法 } } 实例化对象并调用方法\n如果类位于不同的包中，并且没有public访问权限，你需要创建一个实例来调用方法。\n1 2 com.example.MyClass mc = new com.example.MyClass(); mc.method(); // 创建实例并调用方法 跨模块调用\n在Java多模块开发中，跨模块调用主要有两种方式：直接调用和间接调用。\n直接调用\n在同一项目中，一个模块可以直接引用另一个模块的类和方法。这种方式简单直接，但模块间的耦合度较高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 在moduleA的pom.xml中添加对moduleB的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;moduleB\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // 在moduleA中直接调用moduleB的方法 public class ModuleA { public void callModuleBMethod() { com.example.moduleB.MyClass myClass = new com.example.moduleB.MyClass(); myClass.method(); // 直接调用moduleB的方法 } } 间接调用\n间接调用是指通过接口或者服务来实现模块间的调用，一般用于模块间的解耦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 定义接口 public interface MyService { void method(); } // 在moduleB中实现接口 public class MyServiceImpl implements MyService { @Override public void method() { System.out.println(\u0026#34;This is method in MyServiceImpl.\u0026#34;); } } // 在moduleA中通过接口调用moduleB的方法 public class ModuleA { private MyService myService; public ModuleA(MyService myService) { this.myService = myService; } public void callModuleBMethod() { myService.method(); // 通过接口调用moduleB的方法 } } 通过以上方法，你可以轻松地在Java中调用其他Java方法，无论它们位于同一类、同一包、不同包还是不同模块。掌握这些技巧，将有助于提高你的Java编程能力。\n","date":"2025-12-26T14:26:48+08:00","permalink":"https://windovec.github.io/redeem/p/java-base/","title":"Java基础"},{"content":"开启终端和命令行代理脚本 最终 1 2 3 4 5 6 @echo off echo 正在设置代理环境变量... setx http_proxy http://127.0.0.1:7897 setx https_proxy http://127.0.0.1:7897 setx all_proxy socks5://127.0.0.1:7897 pause 无效尝试 1 2 3 4 5 6 7 8 9 10 11 12 13 @echo off echo 当前环境变量： \u0026amp; set http_proxy \u0026amp; set https_proxy \u0026amp; set all_proxy \u0026amp; echo %http_proxy% \u0026amp; echo %https_proxy% \u0026amp; echo %all_proxy% \u0026amp; echo. echo 正在设置代理环境变量... setx http_proxy http://127.0.0.1:7897 setx https_proxy http://127.0.0.1:7897 setx all_proxy socks5://127.0.0.1:7897 set http_proxy= set https_proxy= set all_proxy= timeout /t 1 /nobreak \u0026gt;nul start \u0026#34;Proxy Check\u0026#34; /i cmd /c ^ \u0026#34;echo 检查代理环境变量： \u0026amp; set http_proxy \u0026amp; set https_proxy \u0026amp; set all_proxy \u0026amp; echo %http_proxy% \u0026amp; echo %https_proxy% \u0026amp; echo %all_proxy% \u0026amp; echo. \u0026amp; pause\u0026#34; pause 参数解释\n\u0026amp;：一行中连接多条命令\n^：一个命令换行\nstart [\u0026lt;\u0026quot;title\u0026quot;\u0026gt;] \u0026lt;program\u0026gt;\n/i：不继承环境变量\n未知原因不生效\ncmd\n/c：执行后关闭cmd /k：执行后不关闭cmd 清除资源管理器图标缓存 1 2 3 4 5 6 7 8 9 10 11 taskkill /f /im explorer.exe DEL /F /S /Q /A %LocalAppData%\\IconCache.db DEL /F /S /Q /A %LocalAppData%\\Microsoft\\Windows\\Explorer\\iconcache_*.db del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_32.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_96.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_102.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_256.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_1024.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_idx.db\u0026#34; del /f \u0026#34;%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Explorer\\thumbcache_sr.db\u0026#34; start explorer.exe 5G 移动热点 所选网络波段不可用 中国开放只有149、153、157、161、165这5个信道\n1 Intel 说明 无法在 5 GHz 频段上使用 Windows® 10 移动热点功能\n如何在 Windows® 10 上启用移动热点功能。\n启用 Microsoft Windows® 10 移动热点 功能的步骤。\n项目 内容 您看到了什么？ Windows® 10 移动热点允许您配置热点运行所在的网络频段。在某些情况下，您可能会出现错误，或者看不到 5 GHz 频段的选项。 注意 网络频段选项不受支持，且不会与前代英特尔®无线适配器一起出现。特别是英特尔®无线 7265 家族（ 修订版本 C ）以及更早的版本。 您为什么会看到它？ 某些国家/地区存在监管限制，不允许热点自行在 5 GHz 频段上运行。只有当 Windows® 10 电脑连接至位于特定（被动）的 5GHz 通道上的无线接入点 （AP） 时，您才能在 5GHz 上使用热点。 如何解决. 这种表现是预料之中的，由于存在特定国家的监管限制。但是，对于这些国家/地区，您可以先连接至获批准的 5GHz（被动）通道，然后再启动热点，来使用 5GHz 上的热点。 2 常用WiFi信道与频段 2.4g频段\n2.4 GHz 频段范围内有每隔 5 MHz 分隔的频道14个（除了第14频道与第13频道相隔了 12 MHz）。[2] 40 MHz 频段可以由两个相邻 20 MHz 频段组成。取决于哪个频带是主（控制）频带，哪个频带是从（扩展）频带，路由器可能会显示成 1+5、5+1、9+13、13+9。 5g频段\n5.2G频段\n5.2G的可用信道：36、40、44、48、52、56、60、64； 由于国家使用雷达环境中会与52、56、60、64信道冲突，因此常规模式下建议避开这些雷达信道，以免出现无线终端接入问题。\n5.5G频段\n5.5GHz 属于 5GHz 频段的一部分，在不同国家和地区具体的频率划分可能会有所不同。在中国，5GHz 频段的划分包括 5.470GHz - 5.725GHz 的频率范围。\n5.8G频段\n5.8GHz频段，中国开放只有149、153、157、161、165这5个信道； 其中可支持一组80MHz信道捆绑（149-161）或两组40MHz捆绑（149-153和157-161）； 所以165信道支持20MHz频宽。 165信道不可见是因为当前频宽为20MHz，改频宽后可见。\n剪切板数量 ","date":"2025-12-26T14:23:14+08:00","permalink":"https://windovec.github.io/redeem/p/win-exp/","title":"Windows使用经验"},{"content":"代码块 缩小代码块的字体大小 文件：assets/scss/custom.scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 代码块字体样式 code, pre, .highlight { font-weight: 300 !important; font-size: 1.6rem; } //行内代码 未使用 .article-content code { border: none; border-radius: 4px ; font-size: 0.85em ; } 修复代码出框 文件：assets/partials/layout/article.scss 模块：.article-content 1 2 3 code { word-wrap: break-word; //允许长单词或 URL 地址换行到下一行 } macOS风格 Note 修改 baseurl 后，如果是多级地址，需要使用 .. 返回上级目录，或者 /path\n文件：assets/scss/partials/layout/article.scss 模块：.highlight 1 2 3 4 5 6 7 8 .highlight { background-color: var(--pre-background-color); padding: var(--card-padding); position: relative; border-radius: 10px; max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; 文件：static/img/code-header.svg 1 2 3 4 5 \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;450px\u0026#34; height=\u0026#34;130px\u0026#34;\u0026gt; \u0026lt;ellipse cx=\u0026#34;65\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(220,60,54)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(237,108,96)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;225\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(218,151,33)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(247,193,81)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;385\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(27,161,37)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(100,200,86)\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; 文件：assets/scss/custom.scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 为代码块顶部添加 macos 样式 .article-content { .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(/img/code-header.svg); height: 25px; width: 100%; background-size: 52px; background-repeat: no-repeat; margin-top: -10px; margin-bottom: 0; } } hugo-notice martignoni/hugo-notice: A Hugo theme component to display nice notices\nAs a Hugo module Initialize your existing site as hugo module\n1 hugo mod init github.com/USERNAME/REPO Add the hugo-notice as a hugo module to be able to get upstream changes later\n1 hugo mod get github.com/martignoni/hugo-notice In your site\u0026rsquo;s or theme\u0026rsquo;s configuration file hugo.yaml or hugo.toml, add a new module section and define both hugo-notice and your currently used theme as modules to be imported.\nExample, with hugo.yaml:\n1 2 3 4 module: imports: - path: github.com/martignoni/hugo-notice - path: my-theme or, with hugo.toml,\n1 2 3 4 5 [module] [[module.imports]] path = \u0026#34;github.com/martignoni/hugo-notice\u0026#34; [[module.imports]] path = \u0026#34;my-theme\u0026#34; As a Git submodule Add the hugo-notice as a submodule to be able to get upstream changes later git submodule add https://github.com/martignoni/hugo-notice.git themes/hugo-notice\nAdd hugo-notice as the left-most element of the theme list variable in your site\u0026rsquo;s or theme\u0026rsquo;s configuration file hugo.yaml or hugo.toml.\nExample, with hugo.yaml:\n1 theme: [\u0026#34;hugo-notice\u0026#34;, \u0026#34;my-theme\u0026#34;] or, with hugo.toml,\n1 theme = [\u0026#34;hugo-notice\u0026#34;, \u0026#34;my-theme\u0026#34;] Clone 1 git clone https://github.com/martignoni/hugo-notice.git themes/hugo-notice 后续常用操作 初始化并拉取子模块（克隆项目后）：\n1 git submodule update --init --recursive 更新子模块到最新 commit：\n1 2 3 4 5 6 cd themes/hugo-notice git pull origin main # 然后回到主项目并提交新的 commit ID cd ../.. git add themes/hugo-notice git commit -m \u0026#34;Update hugo-notice theme\u0026#34; 批量更新所有子模块：\n1 git submodule update --remote --merge 示例 1 2 3 4 5 6 7 8 9 10 11 \\{\\{\\\u0026lt; notice note\u0026gt;}} 如果在用户名或密码中包含以下字符和空格字符，必须使用百分比编码转换这些字符： \\: / ? # [ ] @ ! $ \u0026amp; \u0026#39; ( ) * , ; = % 例如，如果您的纯文本密码是p@ssw0rd\u0026#39;9\u0026#39;!，您需要将密码编码为： p%40ssw0rd%279%27%21 \\{\\{\\\u0026lt; /notice \u0026gt;}} Hugo-admonitions KKKZOZ/hugo-admonitions：一款轻量级的 Hugo 模块，为你的内容添加了美丽且可定制的告诫模块。 \u0026mdash; KKKZOZ/hugo-admonitions: A lightweight Hugo module that adds beautiful and customizable admonition blocks to your content.\nGit Clone Inside the folder of your Hugo site, run:\n1 git clone https://github.com/KKKZOZ/hugo-admonitions.git themes/hugo-admonitions Add as the left-most element of the theme list variable in your site\u0026rsquo;s or theme\u0026rsquo;s configuration file or .hugo-admonitions``hugo.yaml``hugo.toml\nWith :hugo.yaml\n1 theme: [\u0026#34;hugo-admonitions\u0026#34;, \u0026#34;my-theme\u0026#34;] With :hugo.toml\n1 theme = [\u0026#34;hugo-admonitions\u0026#34;, \u0026#34;my-theme\u0026#34;] 示例 1 2 [!NOTIFY] System notification: Your password will expire in 30 days. 可用关键词列表 其他关键词默认[!NOTE] Alerts \u0026amp; Emphasis Information \u0026amp; Elaboration Guidance \u0026amp; Interaction [!DANGER] [!INFO] [!TIP] [!ERROR] [!NOTE] [!TASK] [!WARNING] [!ABSTRACT] [!GOAL] [!CAUTION] [!CONCLUSION] [!IDEA] [!IMPORTANT] [!EXAMPLE] [!QUESTION] [!SUCCESS] [!QUOTE] [!NOTIFY] [!CODE] [!EXPERIMENT] [!MEMO] 自定义显示内容\n1 2 [!IDEA] Summary This is a summary using the `IDEA` callout! 警报的扩展语法\n1 2 3 \u0026gt; [!TIP]- Click here to view the tips \u0026gt; [!TIP]+ Click here to view the tips 嵌套\n1 2 3 \u0026gt; [!QUESTION] Can admonitions be nested? \u0026gt; \u0026gt; [!TODO] Yes!, they can. \u0026gt; \u0026gt; \u0026gt; [!EXAMPLE] You can even use multiple layers of nesting. 修改文章字体行距 文件：assets/scss/variables.scss\n模块：:root\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Article content font settings */ :root { --article-font-family: var(--base-font-family); --article-font-size: 1.6rem; @include respond(md) { --article-font-size: 1.7rem; } --article-line-height: 1.85; } 软换行 现象 当需要分段时，输入 Enter ，Typora 会在源码中自动插入一个空行\n1 2 3 Hello World 当排版需要连续的两行时，则输入 Shift + Enter ，换行在 Typora 中能够正确显示\n1 2 Hello World 但这是因为在 Preference \u0026gt; Markdown \u0026gt; Whitespace / Line Break \u0026gt; When Writing 的值设置为了 Preserve whitespace and single line break。\nHugo 输出为 HTML 时不能正确显示。（用其它的 markdown 编辑器打开也可能会有兼容问题）\n连续两行会被显示成这样\n1 Hello World 原因 根据 Markdown Syntax 文档，当从源码输出为 HTML 时，换行符（软换行）不会被转换为 \u0026lt;br /\u0026gt; （硬换行），如果要插入硬换行，你需要在行尾输入两个（或更多）空格。\n根据 GitHub Flavored Markdown Spec 文档，要插入硬换行，你还可以在行尾输入 \\ 或者直接输入 \u0026lt;br /\u0026gt; 。\n解决方案\n在行尾插入 两个空格、 \\ 或 \u0026lt;br /\u0026gt; 的缺点\n\\ 还没有被广泛支持\n\u0026lt;br /\u0026gt; 看着很违和\nHugo 使用 BlackFriday 把 markdown 转换为 HTML，可以在 Hugo 的配置文件中添加以下设置，将换行符强制输出为硬换行。\n1 2 [blackfriday] extensions = [\u0026#34;hardLineBreak\u0026#34;] 后续\nv0.60.0\nGoldmark by @yuin is now the new default library used for Markdown in Hugo. （Nov 27, 2019）\n但是现在 hugo 不再使用Blackfriday改成了Goldmark,可以在下面看到\nhttps://github.com/gohugoio/hugo/issues/9944\n所以就要配置goldmark的hardLineBreak，看了下，在下面找到了答案\nhttps://github.com/yuin/goldmark/issues/247\n之后看了 hugo 的配置\nhttps://gohugo.io/getting-started/configuration-markup/#configure-markup\n只要在hugo.yaml配置\n1 2 3 4 markup: goldmark: renderer: hardWraps: true 添加最后更新时间字段 其实hugo stack这个主题是默认支持显示文章更新时间的，相关代码在 layouts/partials/article/componets/footer.html\n1 2 3 4 5 6 7 8 {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod | time.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} 这段代码很好理解，如果文章配置了lastmod字段，就会在文章结尾的位置显示最后更新时间。但是这样有点麻烦，更新了文章还要手动修改lastmod时间，我决定读取git的文件提交时间。\nUpdate hugo.yaml 可选：修改时间格式 只需要给你的hugo.yaml配置文件增加以下配置就可以实现自动读取git提交时间，这里面的配置大概是两个作用，enableGitInfo 开启git文件信息，然后 lastmod 先读取文章内的信息，没有的话读取git信息，最后读取 date 信息。\n1 2 3 4 5 6 7 frontmatter: lastmod: - \u0026#34;lastmod\u0026#34; # 优先使用 frontmatter 里的 lastmod - \u0026#34;:git\u0026#34; # 如果没有 lastmod，则使用 Git 提交时间 - \u0026#34;date\u0026#34; # 最后 fallback 到 date 字段 enableGitInfo: true Cloudflare pages 然而你部署到 cloudflare/github 之后你会发现所有文章的更新时间都是最后一次提交的git时间，是因为这些CI/CD平台只会读取最新的一条提交记录，解决方法很简单: 在cloudflare pages 修改部署命令拉取更多记录：\n1 git fetch --unshallow \u0026amp;\u0026amp; hugo github workflows添加fetch-depth参数：\n1 2 3 - uses: actions/checkout@v3 with: fetch-depth: 0 修改显示位置 默认的更新时间会显示在文章最下方，我是改到了标题下方会更显眼，读者一点进来就能知道这篇文章是否完全过时了： 修改 layouts/partials/article/componets/details.html 插入这段代码：\n1 2 3 4 5 6 7 8 {{- if ne .Lastmod .Date -}} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;date\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod | time.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} 参考 2\n参考官方文档，在博客项目下创建一个目录layouts\\partials\\article\\components，一定要和stack主题的路径对应上，思想就是hugo生成静态页面时，使用自定义的页面替换stack主题的页面。\ndetails.html页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; // 略... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; // 发布日期代码块 {{ if $showDate }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;date\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{- .Date.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} // 阅读时间代码块 {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.readingTime\u0026#34; .ReadingTime }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} // 剪切到这里，并修改标签和上面的代码块一致 {{ if ne .Lastmod .Date }} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} \u0026lt;/footer\u0026gt; {{ end }} // 略... \u0026lt;/div\u0026gt; footer.html页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; // 略... // 这一块是默认的最后更新时间代码块，将这块代码剪切到details.html的正确位置 {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} \u0026lt;/footer\u0026gt; 按最后修改时间排序 ","date":"2025-12-23T22:45:47+08:00","permalink":"https://windovec.github.io/redeem/p/hugo-cust/","title":"Hugo的自定义美化"},{"content":"初始化仓库 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/WindoveC/WindoveC.github.io.git git push -u origin main git init\n在当前目录初始化一个新的 Git 仓库。\n执行后，Git 会在该目录下创建一个隐藏的 .git 文件夹，用于跟踪版本历史。\n此时项目处于“未跟踪”状态，还没有任何提交。\ngit add .\n将当前目录下所有文件和子目录（除了被 .gitignore 忽略的）添加到 暂存区（staging area）。\n这是告诉 Git：“我打算把这些更改包含在下一次提交中”。\n注意：. 表示当前目录。如果你只想添加特定文件，可以写 git add filename。\ngit commit -m \u0026quot;first commit\u0026quot;\n将暂存区的内容正式提交到本地 Git 仓库，并附上提交信息 \u0026ldquo;first commit\u0026rdquo;。\n这是你项目的第一个提交（initial commit），从此 Git 开始记录变更历史。\ngit branch -M main 将当前分支重命名为 main。\n-M 是 \u0026ndash;move \u0026ndash;force 的缩写，相当于强制重命名。\n在较新版本的 Git（≥2.28）中，默认分支名已从 master 改为 main，而 GitHub 也默认使用 main。\n如果你之前是 master 分支，这条命令确保你使用的是 main，以便与 GitHub 保持一致。\n如果你刚 git init，默认分支可能是 master（取决于 Git 配置），所以这一步很关键。\ngit remote add origin https://github.com/WindoveC/WindoveC.github.io.git 将你的本地仓库与一个远程仓库关联起来。 origin 是远程仓库的别名（约定俗成的名字）。 后面的 URL 是你在 GitHub 上创建的仓库地址（这里是你的 GitHub Pages 仓库）。 git push -u origin main 将本地 main 分支推送到远程仓库的 main 分支。\n-u（或 \u0026ndash;set-upstream）参数会建立本地分支与远程分支的追踪关系。\n设置后，以后只需输入 git push 或 git pull，Git 就知道默认操作哪个远程分支。\n首次推送必须指定远程名和分支名（如 origin main），之后因为有 -u，就可以简化命令。\n清除缓存 .gitignore不生效（关闭跟踪）\n1 2 3 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; // windows使用的命令时，需要使用双引号 clone submodule 注意事项 clone 和 submodule 的文件不会真正上传，可能导致自动执行的job失败 通过 .git 文件夹判断是不是一个项目 release批量下载 组件 GitHub CLI | Take GitHub to the command line 步骤 设置代理\n授权\n1 gh auth login 可选\n**默认查看最近 30 个版本\n1 gh release list -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; 示例\n1 gh release list -R Make-md/makemd 自定义查看更多版本（如 50 或 100 个）\n1 gh release list -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; --limit \u0026lt;number\u0026gt; 示例：\n1 gh release list -R Make-md/makemd --limit 100 下载特定版本的 Release 文件\n1 gh release download \u0026lt;tag\u0026gt; -D \u0026lt;dest\u0026gt; -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; 示例：\n1 gh release download 0.8.14 -D E:\\Documents\\Desktop -R Make-md/makemd 下载最新版本的 Release 文件\n不指定对应的 tag 参数，默认下载的就是最新（Latest）版本的 Release。\n1 gh release download -D \u0026lt;dest\u0026gt; -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; -p * 示例：\n1 gh release download -D E:\\Documents\\Desktop -R Make-md/makemd -p * 下载最新发行版的源代码存档 (ZIP)\n1 gh release download -D \u0026lt;dest\u0026gt; -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; -A zip 示例：\n1 gh release download -D E:\\Documents\\Desktop\\test -R Make-md/makemd -A zip 下载特定发行版的源代码存档\n1 gh release download \u0026lt;tag\u0026gt; -D \u0026lt;dest\u0026gt; -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; --archive=zip 示例：\n1 gh release download 0.7.6 -D E:\\Documents\\Desktop -R Make-md/makemd --archive=zip 下载所有版本的 Release 资源文件\n使用通配符 -p \u0026quot;*\u0026quot; 下载仓库中所有 Release 的资产文件。\n1 gh release download -p \u0026#34;*\u0026#34; -D \u0026lt;dest\u0026gt; -R \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; 示例：\n1 gh release download -p \u0026#34;*\u0026#34; -D E:\\Documents\\Desktop -R Make-md/makemd 批量下载所有版本的源代码存档 (PowerShell 脚本)\n此命令会自动提取版本号并循环执行下载，下次使用时只需更改仓库名称。\n1 gh release list -R Make-md/makemd | Select-String -Pattern \u0026#39;\\d+\\.\\d+(\\.\\d+)?\u0026#39; | %{$_.Matches.Value} | ForEach-Object {Write-Host \u0026#34;Downloading version $_...\u0026#34; ; gh release download $_ -D E:\\Documents\\Desktop\\test -R Make-md/makemd -A zip} ","date":"2025-12-22T23:24:37+08:00","permalink":"https://windovec.github.io/redeem/p/github-base/","title":"Github的基础使用"},{"content":"注释 常规单行注释 :: 代码块（括号内）注释 REM 行末注释 \u0026amp; REM 行头 @：禁止回显（suppress echoing）当前命令本身到命令行窗口。\n代理 设置环境变量 1 2 3 set http_proxy=http://127.0.0.1:7897 set https_proxy=http://127.0.0.1:7897 set all_proxy=socks5://127.0.0.1:7897 检验 1 2 echo %\u0026lt;variable_name\u0026gt;% set \u0026lt;variable_name\u0026gt; 更换目录 不更换驱动器 1 cd {\u0026lt;Relative Path\u0026gt; | \u0026lt;Absolute Path\u0026gt;} 更换驱动器 1 cd /d \u0026lt;Absolute Path\u0026gt; 补全目录 1. powershell 1 mkdir -p \u0026#34;path\\to\\dir\u0026#34; #绝对路径相对路径都可以 或\n1 New-Item -ItemType Directory -Path \u0026#34;...\u0026#34; -Force 2. cmd 1 mkdir \u0026#34;path\\to\\dir\u0026#34; 创建空文件 1 type nul \u0026gt; \u0026#34;C:\\example\\deep\\path\\myfile.txt\u0026#34; 查看当前目录内容 1. 所有 1 dir 2. 按属性筛选 1 /a: -d 排除目录（directories），只显示文件\nd 只显示目录（不含文件） 3. 递归 1 /s 4. 简洁模式 1 /b 5. 排序 1 /o: n (name)、d(date) 加 - ：逆序 6. 支持正则表达式 树状图 1 tree 复制移动 1. copy 1 2 3 4 5 6 7 8 9 10 11 :: 复制单个文件到另一个目录 copy C:\\source\\file.txt D:\\backup\\ :: 复制并重命名 copy C:\\source\\file.txt D:\\backup\\newname.txt :: 复制多个文件（使用通配符） copy C:\\source\\*.txt D:\\backup\\ :: 合并多个文本文件为一个文件（仅适用于文本） copy file1.txt + file2.txt combined.txt 2. move 1 2 3 4 5 6 7 8 9 10 :: 移动文件到另一个目录 move C:\\temp\\old.txt D:\\archive\\ :: 移动并重命名 move C:\\temp\\old.txt D:\\archive\\new.txt :: 移动多个文件 move C:\\temp\\*.log D:\\logs\\ :: move 也可以移动整个空文件夹（但不能移动非空文件夹） 3. 文件夹 robocopy 更强大、可靠\n1 2 3 4 5 :: 复制整个文件夹（包括子目录和文件） robocopy \u0026#34;C:\\source_folder\u0026#34; \u0026#34;D:\\dest_folder\u0026#34; /E :: 移动整个文件夹（复制后删除源） robocopy \u0026#34;C:\\source_folder\u0026#34; \u0026#34;D:\\dest_folder\u0026#34; /E /MOVE /E：包含所有子目录（即使为空） /MOVE：移动文件（复制后删除源目录中的文件） xcopy 传统方法，较新 Windows 中已被弃用）\n1 2 :: 复制整个目录树 xcopy \u0026#34;C:\\source\u0026#34; \u0026#34;D:\\dest\u0026#34; /E /I /E：包含空子目录 /I ：如果目标不存在且复制多个文件，假定目标是目录 setx - 环境变量 set - 终端变量\n本地环境 设置 1 setx MACHINE Brand1 系统环境 设置 1 setx MACHINE Brand1 Computer /m 本地环境 复制 1 setx MYPATH %PATH% 本地环境 追加 1 setx PATH %PATH%;content 本地环境 置空 1 setx path \u0026#34;\u0026#34; 远程 要在名为 computer1 的远程计算机上将本地环境中的 MACHINE 环境变量设置为 Brand1，请键入： 1 setx /s computer1 /u maindom\\hiropln /p p@ssW23 MACHINE Brand1 取注册表项 1 setx TZONE /k HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation\\StandardName 显示文件的内容以及坐标 1 setx /f ipconfig.out /x 取文件内容 坐标 5,11 处**** 1 setx IPADDR /f ipconfig.out /a 5,11 取文件内容 带有分隔符 #$* 的坐标 5,3 处 1 setx OCTET1 /f ipconfig.out /a 5,3 /d #$*. 取文件内容 Gateway 坐标的坐标 0,7 处找到的值，请键入： 1 setx IPGATEWAY /f ipconfig.out /r 0,7 Gateway ","date":"2025-12-22T22:18:59+08:00","permalink":"https://windovec.github.io/redeem/p/cmd-base/","title":"CMD的基础命令"},{"content":" 参考自：https://www.bilibili.com/video/BV1bovfeaEtQ\n必备组件 git 官网：Git HUGO 官网：The world\u0026rsquo;s fastest framework for building websites 配置 安装（本地构建网页） ① git\n二进制文件安装程序 环境变量 ② hugo\n使用预编译拓展版\n链接：https://github.com/gohugoio/hugo/releases/latest\nhugo_extended_0.153.1_windows-amd64\n环境变量\n创建网站资源 1 hugo new site \u0026lt;name\u0026gt; Stack主题 安装 手动安装\n下载模板\nhugo页：Stack\ngithub页：CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n下载release源码\n解压到 {name}/theme\n克隆仓库\n1 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 子模块 1 2 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉 **hugo.toml **和 content/post/rich-content hugo.yaml theme：和主题文件夹同名\nbaseurl：访问网站\nDefaultContentLanguage：默认选择语言\nhasCJKLanguage：按照推荐置为true\nlanguages：可供选择语言列表\nlanguageName：显示语言名 title：页面、标签页标题 weight：排序 params:\nsidebar:\nsubtitle: 页面内的描述 pagination:\npagerSize: 每页最大文章数目\nparams:\nfavicon：标签图标\ndateFormat：时间格式\nsidebar：侧边栏\nemoji：头像右下\nsubtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit.\navatar：头像\nenabled: true\nlocal: true\nsrc: img/avatar.png （/assert下）\nNote 修改 baseurl 后，如果是多级地址，需要使用 .. 返回上级目录，或者 /path\n其他注意参考theme文件夹下路径以及格式即可\n使用 添加内容\n1 2 hugo new content \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;、 示例：hugo new content post/myFirstBlog/index.zh-cn.md FORMAT：如 index**.zh-cn**.index，代表中文文档，忽略代表默认语言 生成静态网页\n命令 hugo -D hugo server -D 命令类型 静态站点生成器（构建命令） 本地开发服务器（预览命令） 是否生成文件到磁盘 ✅ 是，输出到 public/（或 -d 指定目录） ❌ 否，内容仅加载到内存，通过 HTTP 服务提供 部署 github ① 常规部署\n静态网页项目名 {github-username}.github.io\n生成静态网页\n网页 /public 目录下\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/WindoveC/WindoveC.github.io.git git push -u origin main 前往 Setting -\u0026gt; Pages -\u0026gt; Branch\nSource -\u0026gt; Deploy from a branch Branch -\u0026gt; main/(root) ② 自动部署\n创建一个新的私人项目 添加有 repo 和 workflow 权限的私钥到 secrets and variables - actions - repository secrets 创建 .github/workflows/\u0026lt;actionname\u0026gt;.yaml文件\n添加以下内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy ## 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy、 在hugo主文件创建 .gitignore 文件，来避免提交不必要的文件 1 2 3 4 ## 自动生成的文件 public resources .hugo_build.lock 上传文件 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/WindoveC/hugo-redeem.git git push -u origin main 后续更新 1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push 其他组件 Utterances： utterances\n1 2 3 4 utterances: repo: WindoveC/WindoveC.github.io issueTerm: pathname label: Comment 一个基于GitHub issues构建的轻量级评论小部件。使用GitHub issues发布博客评论、维基页面等内容！\n选仓库 到主页填信息 Mapping 默认 label = Comment Twikoo： Twikoo | 一个简洁、安全、免费的静态网站评论系统\n1 2 3 4 5 twikoo: envId: https://wc-redeem-twikoo.netlify.app region: path: lang: zh-cn 云函数部署 - Netlify 云函数部署 | Twikoo 文档\n1 配置 MongoDB Atlas MongoDB Atlas | Twikoo 文档\nMongoDB Atlas 是 MongoDB Inc 提供的 MongoDB 数据库托管服务。免费账户可以永久使用 500 MiB 的数据库，足够存储 Twikoo 评论使用。\n申请 MongoDB AtLas 账号 创建免费 MongoDB 数据库，区域推荐选择离 Twikoo 后端（Vercel / Netlify / AWS Lambda / VPS）地理位置较近的数据中心以获得更低的数据库连接延迟。如果不清楚自己的后端在哪个区域，也可选择 AWS / Oregon (us-west-2)，该数据中心基建成熟，故障率低，且使用 Oregon 州的清洁能源，较为环保 在 Database Access 页面点击 Add New Database User 创建数据库用户，Authentication Method 选 Password，在 Password Authentication 下设置数据库用户名和密码，建议点击 Auto Generate 自动生成一个不含特殊符号的强壮密码并妥善保存。点击 Database User Privileges 下方的 Add Built In Role，Select Role 选择 Atlas Admin，最后点击 Add User 在 Network Access 页面点击 Add IP Address 添加网络白名单。因为 Vercel / Netlify / Lambda 的出口地址不固定，因此 Access List Entry 输入 0.0.0.0/0（允许所有 IP 地址的连接）即可。如果 Twikoo 部署在自己的服务器上，这里可以填入固定 IP 地址。点击 Confirm 保存 在 Database 页面点击 Connect，连接方式选择 Drivers，并记录数据库连接字符串，请将连接字符串中的 \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; 修改为刚刚创建的数据库 用户名:密码 如果在用户名或密码中包含以下字符和空格字符，必须使用百分比编码转换这些字符：\n: / ? # [ ] @ ! $ \u0026amp; \u0026rsquo; ( ) * , ; = %\n例如，如果您的纯文本密码是p@ssw0rd'9\u0026rsquo;!，您需要将密码编码为：\np%40ssw0rd%279%27%21\n（可选）默认的连接字符串没有指定数据库名称，Twikoo 会连接到默认的名为 test 的数据库。如果需要在同一个 MongoDB 里运行其他业务或供多个 Twikoo 实例使用，建立加入数据库名称并配置对应的 ACL。 连接字符串包含了连接到 MongoDB 数据库的所有信息，一旦泄露会导致评论被任何人添加、修改、删除，并有可能获取你的 SMTP、图床 token 等信息。请妥善记录这一字符串，之后需要填入到 Twikoo 的部署平台里。\n2 配置 Netlify 申请 MongoDB Atlas 账号，获取 MongoDB 连接字符串 申请并登录 Netlify 账号，创建一个 Team 打开 twikoojs/twikoo-netlify 点击 fork 将仓库 fork 到自己的账号下 Note 注意修改package.json中的version，默认latest 无法登录数据库\n回到 Netlify，点击 Add new site - Import an existing project 点击 Deploy with GitHub，如果未授权 GitHub 账号，先授权，然后选择前面 fork 的 twikoo-netlify 项目 点击 Add environment variables - New variable，Key 输入 MONGODB_URI，Value 输入前面记录的数据库连接字符串，点击 Deploy twikoo-netlify 部署完成后，点击 Domain settings - 右侧 Options - Edit site name，可以设置属于自己的三级域名（https://xxx.netlify.app） 进入 Site overview，点击上方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示 云函数地址（包含 https:// 前缀和 /.netlify/functions/twikoo 后缀，例如 https://xxx.netlify.app/.netlify/functions/twikoo）即为您的环境 id\n前端部署 在中hugo.yaml填写 envid 即可\n1 2 3 4 5 6 7 params: comments: twikoo: envId: https://xxx.netlify.app region: path: lang: zh-cn ","date":"2025-12-22T22:18:59+08:00","permalink":"https://windovec.github.io/redeem/p/hugo-base/","title":"hugo的基础安装使用部署"}]